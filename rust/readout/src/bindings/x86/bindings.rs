/* automatically generated by rust-bindgen 0.58.1 */

pub const _VCRT_COMPILER_PREPROCESSOR : u32 = 1 ; pub const _SAL_VERSION : u32 = 20 ; pub const __SAL_H_VERSION : u32 = 180000000 ; pub const _USE_DECLSPECS_FOR_SAL : u32 = 0 ; pub const _USE_ATTRIBUTES_FOR_SAL : u32 = 0 ; pub const _CRT_PACKING : u32 = 8 ; pub const _HAS_EXCEPTIONS : u32 = 1 ; pub const _STL_LANG : u32 = 0 ; pub const _HAS_CXX17 : u32 = 0 ; pub const _HAS_CXX20 : u32 = 0 ; pub const _HAS_NODISCARD : u32 = 0 ; pub const WCHAR_MIN : u32 = 0 ; pub const WCHAR_MAX : u32 = 65535 ; pub const WINT_MIN : u32 = 0 ; pub const WINT_MAX : u32 = 65535 ; pub const CRONO_OK : u32 = 0 ; pub const CRONO_WINDRIVER_NOT_FOUND : u32 = 1 ; pub const CRONO_DEVICE_NOT_FOUND : u32 = 2 ; pub const CRONO_NOT_INITIALIZED : u32 = 3 ; pub const CRONO_WRONG_STATE : u32 = 4 ; pub const CRONO_INVALID_DEVICE : u32 = 5 ; pub const CRONO_BUFFER_ALLOC_FAILED : u32 = 6 ; pub const CRONO_TDC_NO_EDGE_FOUND : u32 = 7 ; pub const CRONO_INVALID_BUFFER_PARAMETERS : u32 = 8 ; pub const CRONO_INVALID_CONFIG_PARAMETERS : u32 = 9 ; pub const CRONO_WINDOW_CALIBRATION_FAILED : u32 = 10 ; pub const CRONO_HARDWARE_FAILURE : u32 = 11 ; pub const CRONO_INVALID_ADC_MODE : u32 = 12 ; pub const CRONO_SYNCHRONIZATION_FAILED : u32 = 13 ; pub const CRONO_DEVICE_OPEN_FAILED : u32 = 14 ; pub const CRONO_INTERNAL_ERROR : u32 = 15 ; pub const CRONO_CALIBRATION_FAILURE : u32 = 16 ; pub const CRONO_INVALID_ARGUMENTS : u32 = 17 ; pub const CRONO_PACKET_TYPE_8_BIT_SIGNED : u32 = 0 ; pub const CRONO_PACKET_TYPE_16_BIT_SIGNED : u32 = 1 ; pub const CRONO_PACKET_TYPE_32_BIT_SIGNED : u32 = 2 ; pub const CRONO_PACKET_TYPE_64_BIT_SIGNED : u32 = 3 ; pub const CRONO_PACKET_TYPE_8_BIT_UNSIGNED : u32 = 4 ; pub const CRONO_PACKET_TYPE_16_BIT_UNSIGNED : u32 = 5 ; pub const CRONO_PACKET_TYPE_32_BIT_UNSIGNED : u32 = 6 ; pub const CRONO_PACKET_TYPE_64_BIT_UNSIGNED : u32 = 7 ; pub const CRONO_PACKET_TYPE_TDC_DATA : u32 = 8 ; pub const CRONO_PACKET_TYPE_TIMESTAMP_ONLY : u32 = 128 ; pub const CRONO_PACKET_TYPE_END_OF_BUFFER : u32 = 129 ; pub const CRONO_PACKET_TYPE_TRIGGER_PATTERN : u32 = 130 ; pub const CRONO_PACKET_FLAG_SHORTENED : u32 = 1 ; pub const CRONO_PACKET_FLAG_PACKETS_LOST : u32 = 2 ; pub const CRONO_PACKET_FLAG_OVERFLOW : u32 = 4 ; pub const CRONO_PACKET_FLAG_TRIGGER_MISSED : u32 = 8 ; pub const CRONO_PACKET_FLAG_DMA_FIFO_FULL : u32 = 16 ; pub const CRONO_PACKET_FLAG_HOST_BUFFER_FULL : u32 = 32 ; pub const CRONO_PACKET_FLAG_TDC_NO_EDGE : u32 = 64 ; pub const CRONO_DEVICE_UNKNOWN : u32 = 0 ; pub const CRONO_DEVICE_HPTDC : u32 = 1 ; pub const CRONO_DEVICE_NDIGO5G : u32 = 2 ; pub const CRONO_DEVICE_NDIGO250M : u32 = 4 ; pub const CRONO_DEVICE_NDIGO_AVRG : u32 = 3 ; pub const CRONO_DEVICE_XTDC4 : u32 = 6 ; pub const CRONO_DEVICE_FMC_TDC10 : u32 = 7 ; pub const CRONO_DEVICE_TIMETAGGER4 : u32 = 8 ; pub const CRONO_DEVICE_D_AVE12 : u32 = 9 ; pub const CRONO_DEVICE_D_AVE14 : u32 = 10 ; pub const CRONO_DEVICE_NDIGO2G14 : u32 = 11 ; pub const CRONO_DEVICE_XHPTDC8 : u32 = 12 ; pub const CRONO_DEVICE_NDIGO6G12 : u32 = 13 ; pub const CRONO_DEVICE_STATE_CREATED : u32 = 0 ; pub const CRONO_DEVICE_STATE_INITIALIZED : u32 = 1 ; pub const CRONO_DEVICE_STATE_CONFIGURED : u32 = 2 ; pub const CRONO_DEVICE_STATE_CAPTURING : u32 = 3 ; pub const CRONO_DEVICE_STATE_PAUSED : u32 = 4 ; pub const CRONO_DEVICE_STATE_CLOSED : u32 = 5 ; pub const CRONO_READ_OK : u32 = 0 ; pub const CRONO_READ_NO_DATA : u32 = 1 ; pub const CRONO_READ_INTERNAL_ERROR : u32 = 2 ; pub const CRONO_READ_TIMEOUT : u32 = 3 ; pub const XHPTDC8_API_VERSION : u32 = 1 ; pub const XHPTDC8_STATIC_INFO_VERSION : u32 = 1 ; pub const XHPTDC8_FAST_INFO_VERSION : u32 = 2 ; pub const XHPTDC8_PARAM_INFO_VERSION : u32 = 2 ; pub const XHPTDC8_TEMP_INFO_VERSION : u32 = 3 ; pub const XHPTDC8_CLOCK_INFO_VERSION : u32 = 1 ; pub const XHPTDC8_DEVICE_CONFIG_VERSION : u32 = 3 ; pub const XHPTDC8_MANAGER_CONFIG_VERSION : u32 = 1 ; pub const XHPTDC8_MANAGER_DEVICES_MAX : u32 = 6 ; pub const XHPTDC8_TDC_CHANNEL_COUNT : u32 = 8 ; pub const XHPTDC8_GATE_COUNT : u32 = 8 ; pub const XHPTDC8_TIGER_COUNT : u32 = 9 ; pub const XHPTDC8_TRIGGER_COUNT : u32 = 16 ; pub const XHPTDC8_BUFFER_ALLOCATE : u32 = 0 ; pub const XHPTDC8_BUFFER_USE_PHYSICAL : u32 = 1 ; pub const XHPTDC8_INPUT_BASELINE : f64 = 1.32 ; pub const XHPTDC8_THRESHOLD_P_NIM : f64 = 0.35 ; pub const XHPTDC8_THRESHOLD_P_CMOS : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_LVCMOS_33 : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_LVCMOS_25 : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_LVCMOS_18 : f64 = 0.9 ; pub const XHPTDC8_THRESHOLD_P_TTL : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_LVTTL_33 : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_LVTTL_25 : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_SSTL_3 : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_P_SSTL_2 : f64 = 1.18 ; pub const XHPTDC8_THRESHOLD_N_NIM : f64 = - 0.35 ; pub const XHPTDC8_THRESHOLD_N_CMOS : f64 = - 1.32 ; pub const XHPTDC8_THRESHOLD_N_LVCMOS_33 : f64 = - 1.32 ; pub const XHPTDC8_THRESHOLD_N_LVCMOS_25 : f64 = - 1.25 ; pub const XHPTDC8_THRESHOLD_N_LVCMOS_18 : f64 = - 0.9 ; pub const XHPTDC8_THRESHOLD_N_TTL : f64 = - 1.32 ; pub const XHPTDC8_THRESHOLD_N_LVTTL_33 : f64 = - 1.32 ; pub const XHPTDC8_THRESHOLD_N_LVTTL_25 : f64 = - 1.25 ; pub const XHPTDC8_THRESHOLD_N_SSTL_3 : f64 = - 1.32 ; pub const XHPTDC8_THRESHOLD_N_SSTL_2 : f64 = - 1.25 ; pub const XHPTDC8_TRIGGER_SOURCE_NONE : u32 = 0 ; pub const XHPTDC8_TRIGGER_SOURCE_A : u32 = 1 ; pub const XHPTDC8_TRIGGER_SOURCE_B : u32 = 2 ; pub const XHPTDC8_TRIGGER_SOURCE_C : u32 = 4 ; pub const XHPTDC8_TRIGGER_SOURCE_D : u32 = 8 ; pub const XHPTDC8_TRIGGER_SOURCE_E : u32 = 16 ; pub const XHPTDC8_TRIGGER_SOURCE_F : u32 = 32 ; pub const XHPTDC8_TRIGGER_SOURCE_G : u32 = 64 ; pub const XHPTDC8_TRIGGER_SOURCE_H : u32 = 128 ; pub const XHPTDC8_TRIGGER_SOURCE_TDC1_SYNC : u32 = 256 ; pub const XHPTDC8_TRIGGER_SOURCE_TDC2_SYNC : u32 = 512 ; pub const XHPTDC8_TRIGGER_SOURCE_TDC_EXT_SYNC : u32 = 1024 ; pub const XHPTDC8_TRIGGER_SOURCE_ADC1_CNV : u32 = 2048 ; pub const XHPTDC8_TRIGGER_SOURCE_ADC2_CNV : u32 = 4096 ; pub const XHPTDC8_TRIGGER_SOURCE_SOFTWARE : u32 = 8192 ; pub const XHPTDC8_TRIGGER_SOURCE_AUTO : u32 = 16384 ; pub const XHPTDC8_TRIGGER_SOURCE_ONE : u32 = 32768 ; pub const XHPTDC8_TDCHIT_TYPE_RISING : u32 = 1 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR : u32 = 2 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR_TIMESTAMP_LOST : u32 = 4 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR_ROLLOVER_LOST : u32 = 8 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR_PACKETS_LOST : u32 = 16 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR_SHORTENED : u32 = 32 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR_DMA_FIFO_FULL : u32 = 64 ; pub const XHPTDC8_TDCHIT_TYPE_ERROR_HOST_BUFFER_FULL : u32 = 128 ; pub const XHPTDC8_TDCHIT_TYPE_ADC_INTERNAL : u32 = 1 ; pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR : u32 = 2 ; pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR_UNUSED : u32 = 4 ; pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR_INVALID_TRIGGER : u32 = 8 ; pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR_DATA_LOST : u32 = 16 ; pub const XHPTDC8_OK : u32 = 0 ; pub const XHPTDC8_DEVICE_NOT_FOUND : u32 = 2 ; pub const XHPTDC8_WRONG_STATE : u32 = 4 ; pub const XHPTDC8_INVALID_DEVICE : u32 = 5 ; pub const XHPTDC8_BUFFER_ALLOC_FAILED : u32 = 6 ; pub const XHPTDC8_TDC_NO_EDGE_FOUND : u32 = 7 ; pub const XHPTDC8_INVALID_BUFFER_PARAMETERS : u32 = 8 ; pub const XHPTDC8_INVALID_CONFIG_PARAMETERS : u32 = 9 ; pub const XHPTDC8_TDC_ALIGNMENT_FAILED : u32 = 10 ; pub const XHPTDC8_HARDWARE_FAILURE : u32 = 11 ; pub const XHPTDC8_INVALID_ADC_MODE : u32 = 12 ; pub const XHPTDC8_SYNCHRONIZATION_FAILED : u32 = 13 ; pub const XHPTDC8_DEVICE_OPEN_FAILED : u32 = 14 ; pub const XHPTDC8_INTERNAL_ERROR : u32 = 15 ; pub const XHPTDC8_CALIBRATION_FAILURE : u32 = 16 ; pub const XHPTDC8_INVALID_ARGUMENTS : u32 = 17 ; pub const XHPTDC8_DEVICE_STATE_CREATED : u32 = 0 ; pub const XHPTDC8_DEVICE_STATE_INITIALIZED : u32 = 1 ; pub const XHPTDC8_DEVICE_STATE_CONFIGURED : u32 = 2 ; pub const XHPTDC8_DEVICE_STATE_CAPTURING : u32 = 3 ; pub const XHPTDC8_DEVICE_STATE_PAUSED : u32 = 4 ; pub const XHPTDC8_DEVICE_STATE_CLOSED : u32 = 5 ; pub const XHPTDC8_USER_FLASH_SIZE : u32 = 65536 ; pub const XHPTDC8_NOF_CHANNELS_PER_CARD : u32 = 10 ; pub const XHPTDC8_GATE_OFF : u32 = 0 ; pub const XHPTDC8_GATE_ON : u32 = 1 ; pub const XHPTDC8_TIGER_OFF : u32 = 0 ; pub const XHPTDC8_TIGER_OUTPUT : u32 = 1 ; pub const XHPTDC8_TIGER_BIDI : u32 = 2 ; pub const XHPTDC8_TIGER_BIPOLAR : u32 = 3 ; pub const XHPTDC8_TIGER_MAX_BIPOLAR_PULSE_LENGTH : u32 = 15 ; pub const XHPTDC8_GROUPING_VETO_OFF : u32 = 0 ; pub const XHPTDC8_GROUPING_VETO_INSIDE : u32 = 1 ; pub const XHPTDC8_GROUPING_VETO_OUTSIDE : u32 = 2 ; pub const XHPTDC8_ALIGN_TIGER : u32 = 0 ; pub const XHPTDC8_ALIGN_PIN : u32 = 1 ; pub const XHPTDC8_ALIGN_RESERVED : u32 = 2 ; pub const XHPTDC8_APPLY_YAML_INVALID_ARGUMENT : i32 = - 1 ; pub const XHPTDC8_APPLY_YAML_ERR_NO_CONF_MNGR : i32 = - 10 ; pub const XHPTDC8_APPLY_YAML_ERR_EMPTY_CONF_MNGR : i32 = - 11 ; pub const XHPTDC8_APPLY_YAML_ERR_CONFS_EXCEED_MAX : i32 = - 22 ; pub const XHPTDC8_APPLY_YAML_INVALID_CONFS_STRUTC : i32 = - 23 ; pub const XHPTDC8_APPLY_YAML_ERR_EMPTY_DEV_CONF : i32 = - 31 ; pub const XHPTDC8_APPLY_YAML_INVALID_AUTO_TRIG_PRD : i32 = - 32 ; pub const XHPTDC8_APPLY_YAML_INVALID_AUTO_TRIG_RAND : i32 = - 33 ; pub const XHPTDC8_APPLY_YAML_INVALID_SKIP_ALGNMT : i32 = - 34 ; pub const XHPTDC8_APPLY_YAML_INVALID_ALGNMT_SRCE : i32 = - 35 ; pub const XHPTDC8_APPLY_YAML_THRESHOLDS_EXCEED_MAX : i32 = - 40 ; pub const XHPTDC8_APPLY_YAML_INVALID_THRESHOLD : i32 = - 41 ; pub const XHPTDC8_APPLY_YAML_INVALID_THRESHOLD_STRUCT : i32 = - 42 ; pub const XHPTDC8_APPLY_YAML_INVALID_TRIGGER_FALL : i32 = - 51 ; pub const XHPTDC8_APPLY_YAML_INVALID_TRIGGER_RISING : i32 = - 52 ; pub const XHPTDC8_APPLY_YAML_INVALID_TRIGGER_STRUCT : i32 = - 53 ; pub const XHPTDC8_APPLY_YAML_ERR_TRIGGER_EXCEED_MAX : i32 = - 54 ; pub const XHPTDC8_APPLY_YAML_ERR_GTBLCK_EXCEED_MAX : i32 = - 60 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_MODE : i32 = - 61 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_NEGATE : i32 = - 62 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_RETRIG : i32 = - 63 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_START : i32 = - 64 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_STOP : i32 = - 65 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_STOP_B4_START : i32 = - 66 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_SOURCES : i32 = - 67 ; pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_STRUCT : i32 = - 68 ; pub const XHPTDC8_APPLY_YAML_ERR_CHANNELS_EXCEED_MAX : i32 = - 70 ; pub const XHPTDC8_APPLY_YAML_INVALID_CHANNEL_ENABLE : i32 = - 71 ; pub const XHPTDC8_APPLY_YAML_INVALID_CHANNEL_RISING : i32 = - 72 ; pub const XHPTDC8_APPLY_YAML_INVALID_CHANNEL_STRUCT : i32 = - 73 ; pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_ENABLE : i32 = - 80 ; pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_WDRO : i32 = - 81 ; pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_WDI : i32 = - 82 ; pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_TRTHRESH : i32 = - 83 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_ENABLED : i32 = - 90 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_TRIGCH : i32 = - 91 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_ZEROCH : i32 = - 92 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_ZEROCHOFF : i32 = - 93 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_TRIGDT : i32 = - 95 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETOMD : i32 = - 97 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETORZERO : i32 = - 98 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_RANGE_START : i32 = - 99 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_RANGE_STOP : i32 = - 100 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_WINDO_START : i32 = - 101 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_WINDO_STOP : i32 = - 102 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETO_START : i32 = - 103 ; pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETO_STOP : i32 = - 104 ; pub const XHPTDC8_APPLY_YAML_ERR_TGRBLCKS_EXCEED_MAX : i32 = - 120 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_MODE : i32 = - 121 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_NEGATE : i32 = - 121 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_RETRIG : i32 = - 123 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_START : i32 = - 124 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_STOP : i32 = - 125 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_STOP_B4_START : i32 = - 126 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_SOURCES : i32 = - 127 ; pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_STRUCT : i32 = - 128 ; pub type va_list = * mut :: std :: os :: raw :: c_char ; pub type size_t = :: std :: os :: raw :: c_uint ; pub type __vcrt_bool = bool ; pub type wchar_t = :: std :: os :: raw :: c_ushort ; extern "C" { pub fn __security_init_cookie () ; } extern "fastcall" { pub fn __security_check_cookie (_StackCookie : usize) ; } extern "C" { pub fn __report_gsfailure () ; } extern "C" { pub static mut __security_cookie : usize ; } pub type int_least8_t = :: std :: os :: raw :: c_schar ; pub type int_least16_t = :: std :: os :: raw :: c_short ; pub type int_least32_t = :: std :: os :: raw :: c_int ; pub type int_least64_t = :: std :: os :: raw :: c_longlong ; pub type uint_least8_t = :: std :: os :: raw :: c_uchar ; pub type uint_least16_t = :: std :: os :: raw :: c_ushort ; pub type uint_least32_t = :: std :: os :: raw :: c_uint ; pub type uint_least64_t = :: std :: os :: raw :: c_ulonglong ; pub type int_fast8_t = :: std :: os :: raw :: c_schar ; pub type int_fast16_t = :: std :: os :: raw :: c_int ; pub type int_fast32_t = :: std :: os :: raw :: c_int ; pub type int_fast64_t = :: std :: os :: raw :: c_longlong ; pub type uint_fast8_t = :: std :: os :: raw :: c_uchar ; pub type uint_fast16_t = :: std :: os :: raw :: c_uint ; pub type uint_fast32_t = :: std :: os :: raw :: c_uint ; pub type uint_fast64_t = :: std :: os :: raw :: c_ulonglong ; pub type intmax_t = :: std :: os :: raw :: c_longlong ; pub type uintmax_t = :: std :: os :: raw :: c_ulonglong ; pub type crono_bool_t = u8 ; # [doc = " Basic device data structure for synchronizing cronologic Ndigo5G and HPTDC8 devices"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct crono_device { pub device_type : :: std :: os :: raw :: c_int , # [doc = " For HPTDC use this board id, Ndigo uses configured board id"] pub board_id : :: std :: os :: raw :: c_int , pub device : * mut :: std :: os :: raw :: c_void , } # [test] fn bindgen_test_layout_crono_device () { assert_eq ! (:: std :: mem :: size_of :: < crono_device > () , 12usize , concat ! ("Size of: " , stringify ! (crono_device))) ; assert_eq ! (:: std :: mem :: align_of :: < crono_device > () , 4usize , concat ! ("Alignment of " , stringify ! (crono_device))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_device > ())) . device_type as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (crono_device) , "::" , stringify ! (device_type))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_device > ())) . board_id as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (crono_device) , "::" , stringify ! (board_id))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_device > ())) . device as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (crono_device) , "::" , stringify ! (device))) ; } # [doc = " Packet data structure in ring buffer for packets carrying varying amounts of data."] # [doc = ""] # [doc = " The size of the data[] array is given in the length field."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct crono_packet { pub channel : u8 , pub card : u8 , pub type_ : u8 , pub flags : u8 , pub length : u32 , pub timestamp : i64 , pub data : [u64 ; 1usize] , } # [test] fn bindgen_test_layout_crono_packet () { assert_eq ! (:: std :: mem :: size_of :: < crono_packet > () , 24usize , concat ! ("Size of: " , stringify ! (crono_packet))) ; assert_eq ! (:: std :: mem :: align_of :: < crono_packet > () , 8usize , concat ! ("Alignment of " , stringify ! (crono_packet))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . channel as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . card as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (card))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . type_ as * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . flags as * const _ as usize } , 3usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . length as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (length))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . timestamp as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (timestamp))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet > ())) . data as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (crono_packet) , "::" , stringify ! (data))) ; } # [doc = " Packet data structure in ring buffer for packets carrying only the header."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct crono_packet_only_timestamp { pub channel : u8 , pub card : u8 , pub type_ : u8 , pub flags : u8 , pub length : u32 , pub timestamp : i64 , } # [test] fn bindgen_test_layout_crono_packet_only_timestamp () { assert_eq ! (:: std :: mem :: size_of :: < crono_packet_only_timestamp > () , 16usize , concat ! ("Size of: " , stringify ! (crono_packet_only_timestamp))) ; assert_eq ! (:: std :: mem :: align_of :: < crono_packet_only_timestamp > () , 8usize , concat ! ("Alignment of " , stringify ! (crono_packet_only_timestamp))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet_only_timestamp > ())) . channel as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (crono_packet_only_timestamp) , "::" , stringify ! (channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet_only_timestamp > ())) . card as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (crono_packet_only_timestamp) , "::" , stringify ! (card))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet_only_timestamp > ())) . type_ as * const _ as usize } , 2usize , concat ! ("Offset of field: " , stringify ! (crono_packet_only_timestamp) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet_only_timestamp > ())) . flags as * const _ as usize } , 3usize , concat ! ("Offset of field: " , stringify ! (crono_packet_only_timestamp) , "::" , stringify ! (flags))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet_only_timestamp > ())) . length as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (crono_packet_only_timestamp) , "::" , stringify ! (length))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < crono_packet_only_timestamp > ())) . timestamp as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (crono_packet_only_timestamp) , "::" , stringify ! (timestamp))) ; } # [doc = " struct for the initialization of the xHPTDC8Manager."] # [doc = " This structure MUST be completely INITIALIZED although"] # [doc = " xhptdc8_get_default_init_parameters() will set sensible defaults."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_manager_init_parameters { # [doc = " Version number of the xhptdc8_manager_init_parameters structure"] # [doc = " Is set to XHPTDC8_API_VERSION by xhptdc8_get_default_init_parameters()."] # [doc = " Must be left unchanged."] pub version : :: std :: os :: raw :: c_int , # [doc = " The minimum size of the DMA buffer."] # [doc = " If set to 0, the default size of 16MB is used."] pub buffer_size : i64 , # [doc = " A variant, for reconfiguring the chip for future extension."] pub variant : :: std :: os :: raw :: c_int , # [doc = " A constant for the different devices of cronologic CRONO_DEVICE_*."] # [doc = " Initialized by xhptdc8_get_default_init_parameters()."] # [doc = " Must be left unchanged."] pub device_type : :: std :: os :: raw :: c_int , # [doc = " The update delay of the writing pointer after a packet has been send over PCIe. Specified in"] # [doc = " multiples of 16 ns. Should not be changed by the user."] # [doc = " The base unit is 16 to 32 ns."] pub dma_read_delay : :: std :: os :: raw :: c_int , # [doc = " Several xHPTDC8-PCIe can be used in sync."] # [doc = " If set to 1 enable multiboard operation. If set to 0 disable multiboard operation."] # [doc = " Value is either 'true' or 'false'."] pub multiboard : crono_bool_t , # [doc = " Select external 10 MHz reference."] # [doc = " If set to 1 use external 10 MHz reference. If set to 0 use internal reference."] # [doc = " Value is either 'true' or 'false'."] pub use_ext_clock : crono_bool_t , # [doc = " Ignore calibration values read from device flash."] # [doc = " Value is either 'true' or 'false'."] pub ignore_calibration : crono_bool_t , } # [test] fn bindgen_test_layout_xhptdc8_manager_init_parameters () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_manager_init_parameters > () , 32usize , concat ! ("Size of: " , stringify ! (xhptdc8_manager_init_parameters))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_manager_init_parameters > () , 8usize , concat ! ("Alignment of " , stringify ! (xhptdc8_manager_init_parameters))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . version as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . buffer_size as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (buffer_size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . variant as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (variant))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . device_type as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (device_type))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . dma_read_delay as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (dma_read_delay))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . multiboard as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (multiboard))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . use_ext_clock as * const _ as usize } , 29usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (use_ext_clock))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_init_parameters > ())) . ignore_calibration as * const _ as usize } , 30usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_init_parameters) , "::" , stringify ! (ignore_calibration))) ; } # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct TDCHit { # [doc = " The time stamp of the hit in picoseconds."] # [doc = " If grouping is enabled the timestamp is relative to the trigger or the separate"] # [doc = " zero reference of the group. Otherwise the timestampe is continuously"] # [doc = " counting up from the call to start_capture()"] pub time : i64 , # [doc = " For the first board in the system this 0 to 7 for the TDC channels A to H. 8 or 9 for ADC data."] # [doc = " Data from channels 8 and 9 should usually be treated as data from the same channel."] # [doc = " For the other boards the channel number is incremented by board_id * 10"] pub channel : u8 , # [doc = " Additional information on the type of hit recorded."] # [doc = " It is of one of the values XHPTDC8_TDCHIT_TYPE_* or'ed with error flags if required."] pub type_ : u8 , # [doc = " For ADC hits this contains the sampled voltage. For TDC hits the content is undefined."] pub bin : u16 , } # [test] fn bindgen_test_layout_TDCHit () { assert_eq ! (:: std :: mem :: size_of :: < TDCHit > () , 16usize , concat ! ("Size of: " , stringify ! (TDCHit))) ; assert_eq ! (:: std :: mem :: align_of :: < TDCHit > () , 8usize , concat ! ("Alignment of " , stringify ! (TDCHit))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < TDCHit > ())) . time as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (TDCHit) , "::" , stringify ! (time))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < TDCHit > ())) . channel as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (TDCHit) , "::" , stringify ! (channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < TDCHit > ())) . type_ as * const _ as usize } , 9usize , concat ! ("Offset of field: " , stringify ! (TDCHit) , "::" , stringify ! (type_))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < TDCHit > ())) . bin as * const _ as usize } , 10usize , concat ! ("Offset of field: " , stringify ! (TDCHit) , "::" , stringify ! (bin))) ; } extern "C" { # [doc = " Read a multitude of hits into a buffer provided by the user."] # [doc = " If grouping is enabled a single group is read."] # [doc = " If grouping is disabled all availabe data is read."] # [doc = " In all cases, data is copied to buffer up to the size of the buffer."] # [doc = ""] # [doc = " @param hit_buf[out]. Buffer allocated and provdied by the user."] # [doc = " @param read_max[out]. Size of the buffer."] # [doc = ""] # [doc = " @returns Returns the number of read hits."] pub fn xhptdc8_read_hits (hit_buf : * mut TDCHit , read_max : size_t) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " TODO"] # [doc = ""] # [doc = ""] # [doc = " @param absolute_trigger_timestamp[out]. The absolute trigger timestamp in picoseconds."] # [doc = " @param hit_counter[out].\t\t\tBuffer allocated and provded by the user. This array provides the hit counts per channel."] # [doc = "\t\t\t\t\t\t\t\t\tThe maximum count is defined by number_of_hits. Set the buffer size to number_of_channels."] # [doc = "\t\t\t\t\t\t\t\t\tChannels 8 and 9 mod XHPTDC8_NOF_CHANNELS_PER_CARD stay empty."] # [doc = " @param tdc_array[out].\t\t\tBuffer allocated and provded by the user. This is a matrix containing a list timestamps per channel."] # [doc = "\t\t\t\t\t\t\t\t\tSet the buffer size to number_of_channels x number_of_hits."] # [doc = "\t\t\t\t\t\t\t\t\tRemark: Adc channels per card are merged to channel 8 mod XHPTDC8_NOF_CHANNELS_PER_CARD,"] # [doc = "\t\t\t\t\t\t\t\t\tso 9 mod XHPTDC8_NOF_CHANNELS_PER_CARD stays empty."] # [doc = " @param adc_counter[out].\t\t\tBuffer allocated and provded by the user. This array provides the hit counts per adc channel."] # [doc = "\t\t\t\t\t\t\t\t\tThe maximum count is defined by number_of_hits."] # [doc = "\t\t\t\t\t\t\t\t\tSet the buffer size to devices count (use function xhptdc8_count_devices)."] # [doc = " @param adc_value[out].\t\t\tBuffer allocated and provded by the user. This array provides the adc value per channel."] # [doc = "\t\t\t\t\t\t\t\t\tThe maximum is defined by number_of_hits. Set the buffer size to devices count."] # [doc = " @param number_of_tdcs[in].\t\tThis is the devices count that can be calculated by the function xhptdc8_count_devices."] # [doc = " @param number_of_channels[in].\tThis has to be calculated by XHPTDC8_NOF_CHANNELS_PER_CARD * number_of_tdcs."] # [doc = " @param number_of_hits[in].\t\tThis is used to define buffer sizes."] # [doc = ""] # [doc = " @returns Returns the number of read hits."] pub fn xhptdc8_read_group_matrix (absolute_trigger_timestamp : * mut i64 , hit_counter : * mut i32 , tdc_array : * mut i64 , adc_counter : * mut i32 , adc_value : * mut i32 , number_of_tdcs : i32 , number_of_channels : i32 , number_of_hits : i32) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Finalize the driver for this device."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_close () -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Start the timing generator of an individual board."] # [doc = " This can be done independently of the state of the data acquisition"] # [doc = ""] # [doc = ""] # [doc = " @param index[in]. The index of the device."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_start_tiger (index : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Stop the timing generator of an individual board."] # [doc = " This can be done independently of the state of the data acquisition"] # [doc = ""] # [doc = ""] # [doc = " @param index[in]. The index of the device."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_stop_tiger (index : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Start data acquisition."] # [doc = " Device manager must be initialized using xhptdc8_init()."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_start_capture () -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Pause a started data acquisition."] # [doc = " It doesn't allow for a configuration change."] # [doc = ""] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_pause_capture () -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Call this to resume data acquisition after a call to xhptdc8_pause_capture()."] # [doc = " It doesn't allow for a configuration change."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_continue_capture () -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Stop data acquisition."] # [doc = ""] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_stop_capture () -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Generate a software trigger event."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_software_trigger (index : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } # [doc = " Structure contains static information."] # [doc = ""] # [doc = " This structure contains information about the board that does not change during run time."] # [doc = " It is provided by the function xhptdc8_get_static_info()."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_static_info { # [doc = " The number of bytes occupied by the structure."] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = " Set to XHPTDC8_STATIC_INFO_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " ID of the board."] # [doc = " All xHPTDC8-PCIe boards in the system are numbered according in order of their serial numbers starting at zero."] pub board_id : :: std :: os :: raw :: c_int , # [doc = " Encoded version number for the driver."] # [doc = ""] # [doc = " The lower three bytes contain a triple level hierarchy of version numbers."] # [doc = " E.g. 0x010103 codes version 1.1.3."] # [doc = ""] # [doc = " A change in the first digit generally requires a recompilation of user applications."] # [doc = " Change in the second digit denote significant improvements or changes that don't break compatibility"] # [doc = " and the third digit changes with minor bugfixes and the like."] pub driver_revision : :: std :: os :: raw :: c_int , # [doc = " The build number of the driver according to cronologic's internal versioning system."] pub driver_build_revision : :: std :: os :: raw :: c_int , # [doc = " Revision number of the FPGA configuration"] pub firmware_revision : :: std :: os :: raw :: c_int , # [doc = " Board revision number."] # [doc = ""] # [doc = " The board revision number can be read from a register. It is a four bit number"] # [doc = " that changes when the schematic of the board is changed."] # [doc = " - 0: Experimental first board Version. Labeled \"Rev. 1\""] # [doc = " - 2: First commercial Version. Labeled \"Rev. 2\""] pub board_revision : :: std :: os :: raw :: c_int , # [doc = " Describes the schematic configuration of the board."] # [doc = ""] # [doc = " The same board schematic can be populated in multiple variants."] # [doc = " This is a eight bit-code that can be read from a register."] pub board_configuration : :: std :: os :: raw :: c_int , # [doc = " Subversion revision id of the FPGA configuration."] # [doc = ""] # [doc = " A number to track builds of the firmware in more detail than the firmware revision. It changes"] # [doc = " with every change in the firmware, even if there is no visible effect for the user. The subversion"] # [doc = " revision number can be read from a register."] pub subversion_revision : :: std :: os :: raw :: c_int , # [doc = " 16bit factory ID of the TDC chip."] # [doc = ""] # [doc = " This is the chipID as read from the 16 bit TDC chip id register."] pub chip_id : [:: std :: os :: raw :: c_int ; 2usize] , # [doc = " Serial number"] # [doc = ""] # [doc = " With year and running number in 8.24 format. The number is identical to the one"] # [doc = " printed on the silvery sticker on the board."] pub board_serial : :: std :: os :: raw :: c_int , # [doc = " High 32 bits of 64 bit manufacturer serial number of the flash chip."] pub flash_serial_high : u32 , # [doc = " Low 32 bits of 64 bit manufacturer serial number of the flash chip."] pub flash_serial_low : u32 , # [doc = " Calibration data read from flash is valid."] # [doc = ""] # [doc = " If not 'false', the driver found valid calibration data in the flash on the board and is using it."] pub flash_valid : crono_bool_t , # [doc = " Calibration date"] # [doc = ""] # [doc = " DIN EN ISO 8601 string YYYY-MM-DD HH:DD describing the time when the card was calibrated."] pub calibration_date : [:: std :: os :: raw :: c_char ; 20usize] , } # [test] fn bindgen_test_layout_xhptdc8_static_info () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_static_info > () , 80usize , concat ! ("Size of: " , stringify ! (xhptdc8_static_info))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_static_info > () , 4usize , concat ! ("Alignment of " , stringify ! (xhptdc8_static_info))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . board_id as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (board_id))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . driver_revision as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (driver_revision))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . driver_build_revision as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (driver_build_revision))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . firmware_revision as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (firmware_revision))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . board_revision as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (board_revision))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . board_configuration as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (board_configuration))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . subversion_revision as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (subversion_revision))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . chip_id as * const _ as usize } , 36usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (chip_id))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . board_serial as * const _ as usize } , 44usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (board_serial))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . flash_serial_high as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (flash_serial_high))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . flash_serial_low as * const _ as usize } , 52usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (flash_serial_low))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . flash_valid as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (flash_valid))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_static_info > ())) . calibration_date as * const _ as usize } , 57usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_static_info) , "::" , stringify ! (calibration_date))) ; } extern "C" { # [doc = " Returns static information about the device."] # [doc = ""] # [doc = " Gets a structure that contains information about the board that does not change during"] # [doc = " run time."] # [doc = ""] # [doc = " @param index[in].The index of the device."] # [doc = " @param info[out]. Buffer allocated and provided by the user to have a copy of the structure."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_static_info (index : :: std :: os :: raw :: c_int , info : * mut xhptdc8_static_info) -> :: std :: os :: raw :: c_int ; } # [doc = " Contains fast dynamic information."] # [doc = ""] # [doc = " This structure is filled using function xhptdc8_get_fast_info()."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_fast_info { # [doc = " The number of bytes occupied by the structure"] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = ""] # [doc = " Set to XHPTDC8_FAST_INFO_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " Speed of the FPGA fan in rounds per minute."] # [doc = ""] # [doc = " Reports 0, if no fan is present."] pub fpga_rpm : :: std :: os :: raw :: c_int , # [doc = " Alert bits from temperature sensor and the system monitor."] # [doc = ""] # [doc = " Bit 0 is set if the TDC temperature exceeds 140 degree C. In this case the TDC did shut down"] # [doc = " and the device needs to be reinitialized."] pub alerts : :: std :: os :: raw :: c_int , # [doc = " Reports power management confguration of PCIe lanes."] # [doc = " Should always be 0."] pub pcie_pwr_mgmt : :: std :: os :: raw :: c_int , # [doc = " Number of PCIe lanes the card uses."] # [doc = " Should always be 1 for the xHPTDC8-PCIe."] pub pcie_link_width : :: std :: os :: raw :: c_int , # [doc = " Maximum size for a single PCIe transaction in bytes. Depends on system configuration."] pub pcie_max_payload : :: std :: os :: raw :: c_int , # [doc = " The current state of the device."] # [doc = " Should be one of the values XHPTDC8_DEVICE_STATE_*"] pub state : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_xhptdc8_fast_info () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_fast_info > () , 32usize , concat ! ("Size of: " , stringify ! (xhptdc8_fast_info))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_fast_info > () , 4usize , concat ! ("Alignment of " , stringify ! (xhptdc8_fast_info))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . fpga_rpm as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (fpga_rpm))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . alerts as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (alerts))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . pcie_pwr_mgmt as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (pcie_pwr_mgmt))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . pcie_link_width as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (pcie_link_width))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . pcie_max_payload as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (pcie_max_payload))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_fast_info > ())) . state as * const _ as usize } , 28usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_fast_info) , "::" , stringify ! (state))) ; } extern "C" { # [doc = " Returns fast dynamic information about the device."] # [doc = ""] # [doc = " This call gets a structure that contains dynamic information that can be obtained within a"] # [doc = " few microseconds."] # [doc = ""] # [doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of the structure."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_fast_info (index : :: std :: os :: raw :: c_int , info : * mut xhptdc8_fast_info) -> :: std :: os :: raw :: c_int ; } # [doc = " Contains information that may change with configuration"] # [doc = ""] # [doc = " Structure is filled by xhptdc8_get_param_info()."] # [doc = " This structure contains information that changes indirectly due to configuration changes."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_param_info { # [doc = " The number of bytes occupied by the structure."] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = ""] # [doc = " Set to XHPTDC8_PARAM_INFO_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " Binsize (in ps) of the measured TDC data."] # [doc = ""] # [doc = " The TDC main clk is running at a frequency of 76.8 GHz resulting in a binsize of ~13.0208 ps."] pub binsize : f64 , # [doc = " Number of TDC channels of the board."] # [doc = ""] # [doc = " It's currently fixed at 8."] pub channels : :: std :: os :: raw :: c_int , # [doc = " Bit assignment of each enabled input channel."] # [doc = ""] # [doc = " Bit 0 <= n < 8 is set if channel n is enabled."] pub channel_mask : :: std :: os :: raw :: c_int , # [doc = " The total amount of DMA buffer in bytes."] pub total_buffer : i64 , } # [test] fn bindgen_test_layout_xhptdc8_param_info () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_param_info > () , 32usize , concat ! ("Size of: " , stringify ! (xhptdc8_param_info))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_param_info > () , 8usize , concat ! ("Alignment of " , stringify ! (xhptdc8_param_info))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_param_info > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_param_info) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_param_info > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_param_info) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_param_info > ())) . binsize as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_param_info) , "::" , stringify ! (binsize))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_param_info > ())) . channels as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_param_info) , "::" , stringify ! (channels))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_param_info > ())) . channel_mask as * const _ as usize } , 20usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_param_info) , "::" , stringify ! (channel_mask))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_param_info > ())) . total_buffer as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_param_info) , "::" , stringify ! (total_buffer))) ; } extern "C" { # [doc = " Returns information that may change with configuration"] # [doc = ""] # [doc = " Gets a structure that contains information that changes indirectly due to configuration"] # [doc = " changes."] # [doc = ""] # [doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of the structure."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_param_info (index : :: std :: os :: raw :: c_int , info : * mut xhptdc8_param_info) -> :: std :: os :: raw :: c_int ; } # [doc = " Contains temperature measurements"] # [doc = ""] # [doc = " CAVE: TDC temp diode takes about 2.5 us after wakeup from power down to provide a valid measurement"] # [doc = " Structure filled by xhptdc8_get_temperature_info()"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_temperature_info { # [doc = " The number of bytes occupied by the structure"] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = ""] # [doc = " Set to XHPTDC8_TEMP_INFO_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " Temperature for each of the TDC chips in �C."] pub tdc : [f32 ; 2usize] , } # [test] fn bindgen_test_layout_xhptdc8_temperature_info () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_temperature_info > () , 16usize , concat ! ("Size of: " , stringify ! (xhptdc8_temperature_info))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_temperature_info > () , 4usize , concat ! ("Alignment of " , stringify ! (xhptdc8_temperature_info))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_temperature_info > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_temperature_info) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_temperature_info > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_temperature_info) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_temperature_info > ())) . tdc as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_temperature_info) , "::" , stringify ! (tdc))) ; } extern "C" { # [doc = " Get temperature measurements from multiple sources on the board."] # [doc = ""] # [doc = " @param index[in]. The index of the device."] # [doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of the structure."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_temperature_info (index : :: std :: os :: raw :: c_int , info : * mut xhptdc8_temperature_info) -> :: std :: os :: raw :: c_int ; } # [doc = " Contains information about the active clock source."] # [doc = ""] # [doc = " Structure is filled by xhptdc8_clock_info()."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_clock_info { # [doc = " The number of bytes occupied by the structure."] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = ""] # [doc = " Set to XHPTDC8_CLOCK_INFO_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " CDCE62005 PLL locked. Set if the jitter cleaning PLL clock synthesizer achieved lock."] # [doc = " Value is either 'true' or 'false'."] pub cdce_locked : crono_bool_t , # [doc = " Version information from the CDCE62005 clock synthesizer."] pub cdce_version : :: std :: os :: raw :: c_int , # [doc = " Source for the clock synthesizer is usually the 10MHz on board oscillator."] # [doc = " Value: 'false': internal 10 MHz, 'true': LEMO clock"] pub use_ext_clock : crono_bool_t , # [doc = " Set if the FPGA datapath PLLs achieved lock."] # [doc = " Value is either 'true' or 'false'."] pub fpga_locked : crono_bool_t , } # [test] fn bindgen_test_layout_xhptdc8_clock_info () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_clock_info > () , 20usize , concat ! ("Size of: " , stringify ! (xhptdc8_clock_info))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_clock_info > () , 4usize , concat ! ("Alignment of " , stringify ! (xhptdc8_clock_info))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_clock_info > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_clock_info) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_clock_info > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_clock_info) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_clock_info > ())) . cdce_locked as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_clock_info) , "::" , stringify ! (cdce_locked))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_clock_info > ())) . cdce_version as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_clock_info) , "::" , stringify ! (cdce_version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_clock_info > ())) . use_ext_clock as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_clock_info) , "::" , stringify ! (use_ext_clock))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_clock_info > ())) . fpga_locked as * const _ as usize } , 17usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_clock_info) , "::" , stringify ! (fpga_locked))) ; } extern "C" { # [doc = " Get information on clocking configuration an status."] # [doc = ""] # [doc = " @param index[in]. The index of the device."] # [doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of the structure."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_clock_info (index : :: std :: os :: raw :: c_int , info : * mut xhptdc8_clock_info) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Returns most recent error message."] # [doc = ""] # [doc = " @param index[in]. The index of the device. If set to -1 returns error message of the manager."] pub fn xhptdc8_get_last_error_message (index : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [doc = " Returns the type of the device as CRONO_DEVICE_XHPTDC8."] # [doc = ""] # [doc = " @param index[in]. The index of the device."] pub fn xhptdc8_get_device_type (index : :: std :: os :: raw :: c_int) -> :: std :: os :: raw :: c_int ; } # [doc = " Contains TDC channel settings."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_channel { # [doc = " Enable TDC channel."] # [doc = " Value is either 'true' or 'false'."] pub enable : crono_bool_t , # [doc = " Select which edge of the signal is measured by the TDC."] # [doc = " Value is either 'true' or 'false'."] pub rising : crono_bool_t , } # [test] fn bindgen_test_layout_xhptdc8_channel () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_channel > () , 2usize , concat ! ("Size of: " , stringify ! (xhptdc8_channel))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_channel > () , 1usize , concat ! ("Alignment of " , stringify ! (xhptdc8_channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_channel > ())) . enable as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_channel) , "::" , stringify ! (enable))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_channel > ())) . rising as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_channel) , "::" , stringify ! (rising))) ; } # [doc = " Contains settings of timing generator."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_tiger_block { # [doc = " Enables the desired mode of operation for the TiGeR."] # [doc = " It is of one of the values XHPTDC8_TIGER_*"] pub mode : :: std :: os :: raw :: c_int , # [doc = " Inverts output polarity."] # [doc = " For gating blocks, a value of 'false' enables inputs between start and stop,"] # [doc = " A value of 'true' enables outputs outside that interval."] # [doc = " The TiGeR creates a high pulse from start to stop unless negated."] # [doc = " Default value is 'false'."] pub negate : crono_bool_t , # [doc = " Enables retrigger setting."] # [doc = " If enabled, the timer is reset to the value of the start parameter,"] # [doc = " whenever the input signal is set while waiting to reach the stop time."] # [doc = " Value is either 'true' or 'false'."] # [doc = " Default value is 'false'"] pub retrigger : crono_bool_t , # [doc = " Not implemented."] pub extend : crono_bool_t , # [doc = " The start time at which the TiGeR or Gate output is set, relative to the trigger input."] # [doc = " It is in multiples of 20 ns/3 = 6.6 ns."] # [doc = " Must fullfil condition: 0 <= start <= stop <= (2^16 - 1)"] pub start : :: std :: os :: raw :: c_int , # [doc = " The duration from start time in which the TiGeR or Gate output is set, relative to the trigger input."] # [doc = " It is in multiples of 20 ns/3 = 6.6 ns."] # [doc = " Must fullfil condition: 0 <= start <= stop <= (2^16 - 1)"] pub stop : :: std :: os :: raw :: c_int , # [doc = " A bit mask with a bit set for all trigger sources that can trigger this TiGeR or Gate block."] # [doc = " Default value is XHPTDC8_TRIGGER_SOURCE_A."] pub sources : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_xhptdc8_tiger_block () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_tiger_block > () , 20usize , concat ! ("Size of: " , stringify ! (xhptdc8_tiger_block))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_tiger_block > () , 4usize , concat ! ("Alignment of " , stringify ! (xhptdc8_tiger_block))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . mode as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (mode))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . negate as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (negate))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . retrigger as * const _ as usize } , 5usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (retrigger))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . extend as * const _ as usize } , 6usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (extend))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . start as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (start))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . stop as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (stop))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_tiger_block > ())) . sources as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_tiger_block) , "::" , stringify ! (sources))) ; } # [doc = " For each input, this structure determines wheter rising or falling edges on the inputs create trigger"] # [doc = " events for the TiGeR and gating blocks."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_trigger { # [doc = " If set to 'true', a trigger event is created inside the FPGA at the falling edge."] # [doc = " Value is either 'true' or 'false'."] pub falling : crono_bool_t , # [doc = " If set to 'true', a trigger event is created inside the FPGA at the rising edge."] # [doc = " Value is either 'true' or 'false'."] pub rising : crono_bool_t , } # [test] fn bindgen_test_layout_xhptdc8_trigger () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_trigger > () , 2usize , concat ! ("Size of: " , stringify ! (xhptdc8_trigger))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_trigger > () , 1usize , concat ! ("Alignment of " , stringify ! (xhptdc8_trigger))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_trigger > ())) . falling as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_trigger) , "::" , stringify ! (falling))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_trigger > ())) . rising as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_trigger) , "::" , stringify ! (rising))) ; } # [doc = " ADC channel config"] # [doc = " Contains ADC channel settings"] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_adc_channel { # [doc = " Enable ADC measurements."] # [doc = " Value is either 'true' or 'false'."] pub enable : crono_bool_t , # [doc = " Send watchdog measurements."] # [doc = " Value is either 'true' or 'false'."] pub watchdog_readout : crono_bool_t , # [doc = " Number of 150 MHz clock cycles between watchdog triggers."] pub watchdog_interval : :: std :: os :: raw :: c_int , # [doc = " Trigger threshold of ADC trigger input."] pub trigger_threshold : f64 , } # [test] fn bindgen_test_layout_xhptdc8_adc_channel () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_adc_channel > () , 16usize , concat ! ("Size of: " , stringify ! (xhptdc8_adc_channel))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_adc_channel > () , 8usize , concat ! ("Alignment of " , stringify ! (xhptdc8_adc_channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_adc_channel > ())) . enable as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_adc_channel) , "::" , stringify ! (enable))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_adc_channel > ())) . watchdog_readout as * const _ as usize } , 1usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_adc_channel) , "::" , stringify ! (watchdog_readout))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_adc_channel > ())) . watchdog_interval as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_adc_channel) , "::" , stringify ! (watchdog_interval))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_adc_channel > ())) . trigger_threshold as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_adc_channel) , "::" , stringify ! (trigger_threshold))) ; } # [doc = " This structure configures the behaviour of the grouping functionality."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_grouping_configuration { pub enabled : crono_bool_t , # [doc = " Channel number that is used to trigger the creation of a group."] # [doc = ""] # [doc = " By default the trigger channels defines the zero point reference for the group event timestamps."] pub trigger_channel : :: std :: os :: raw :: c_int , # [doc = " Use this to define additional trigger channels."] # [doc = " There is an OR-disjuction with the trigger_channel."] # [doc = ""] pub trigger_channel_bitmask : u64 , # [doc = " Start of group range relative to the trigger channel."] # [doc = " Values in the interval from range_start to range_stop are included in the group."] # [doc = " Either or both values can be negative to create common-stop behaviour."] # [doc = " -2^63 <= range_start < range_stop < 2^63"] # [doc = " Intervals are always provided in picoseconds, independently of the bin size of the TDC."] pub range_start : i64 , # [doc = " End of group range relative to the trigger channel."] # [doc = " Intervals are always provided in picoseconds, independently of the bin size of the TDC."] pub range_stop : i64 , # [doc = " Dead time before new group start trigger is recognized."] # [doc = " 0 <= trigger_deadtime < 2^63"] # [doc = " Intervals are always provided in picoseconds, independently of the bin size of the TDC."] pub trigger_deadtime : i64 , # [doc = " Optionally, a different channel can be used to calculate the relative timestamps in a group."] # [doc = " This is disabled per default by setting this paramteer to -1."] pub zero_channel : :: std :: os :: raw :: c_int , # [doc = " This offset in picoseconds is added to relative timestamps within a group."] pub zero_channel_offset : i64 , # [doc = " Set a bitmask of channels, a group is only created"] # [doc = " if there is at least one"] # [doc = " hit in the windows defined by windows_start and window_stop."] # [doc = " Usage is equivalent to trigger_channel_bitmask."] pub window_hit_channels : u64 , # [doc = " A group is only created if there is at least one hit in the window defined by"] # [doc = " window_start and window_stop, and when require_window_hit is set 'true'."] # [doc = " -2^63 <= window_start < window_stop < 2^63"] # [doc = " Intervals are always provided in picoseconds, independently of the bin size of the TDC."] pub window_start : i64 , # [doc = " A group is only created if there is at least one hit in the window defined by"] # [doc = " window_start and window_stop, and when require_window_hit is set 'true'."] # [doc = " -2^63 <= window_start < window_stop < 2^63"] # [doc = " Intervals are always provided in picoseconds, independently of the bin size of the TDC."] pub window_stop : i64 , # [doc = " A window defined by veto_start and veto_stop can be used to suppress hits."] # [doc = " The functionality is very similar to the gating blocks but is defined in software."] # [doc = " This feature can not be used to improve FIFO usage or PCIe bandwidth usage."] # [doc = " It is of one of the values XHPTDC8_GROUPING_VETO_*"] pub veto_mode : :: std :: os :: raw :: c_int , # [doc = " A window defined by veto_start and veto_stop can be used to suppress hits."] # [doc = " -2^63 <= veto_start <= veto_stop < 2^63"] pub veto_start : i64 , # [doc = " A window defined by veto_start and veto_stop can be used to suppress hits."] # [doc = " -2^63 <= veto_start <= veto_stop < 2^63"] pub veto_stop : i64 , # [doc = "\tIf veto is enabled, veto filtering is active for channels"] # [doc = "\tdefined by a channel bitmask."] # [doc = "\tAs default, filtering is active for all channels."] pub veto_active_channels : u64 , pub veto_relative_to_zero : crono_bool_t , pub ignore_empty_events : crono_bool_t , pub overlap : crono_bool_t , } # [test] fn bindgen_test_layout_xhptdc8_grouping_configuration () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_grouping_configuration > () , 120usize , concat ! ("Size of: " , stringify ! (xhptdc8_grouping_configuration))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_grouping_configuration > () , 8usize , concat ! ("Alignment of " , stringify ! (xhptdc8_grouping_configuration))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . enabled as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (enabled))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . trigger_channel as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (trigger_channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . trigger_channel_bitmask as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (trigger_channel_bitmask))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . range_start as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (range_start))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . range_stop as * const _ as usize } , 24usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (range_stop))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . trigger_deadtime as * const _ as usize } , 32usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (trigger_deadtime))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . zero_channel as * const _ as usize } , 40usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (zero_channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . zero_channel_offset as * const _ as usize } , 48usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (zero_channel_offset))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . window_hit_channels as * const _ as usize } , 56usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (window_hit_channels))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . window_start as * const _ as usize } , 64usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (window_start))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . window_stop as * const _ as usize } , 72usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (window_stop))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . veto_mode as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (veto_mode))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . veto_start as * const _ as usize } , 88usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (veto_start))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . veto_stop as * const _ as usize } , 96usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (veto_stop))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . veto_active_channels as * const _ as usize } , 104usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (veto_active_channels))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . veto_relative_to_zero as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (veto_relative_to_zero))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . ignore_empty_events as * const _ as usize } , 113usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (ignore_empty_events))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_grouping_configuration > ())) . overlap as * const _ as usize } , 114usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_grouping_configuration) , "::" , stringify ! (overlap))) ; } # [doc = " This is the structure containing the configuration information."] # [doc = " It uses the multiple substructures to configure various aspects of the board."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_device_configuration { # [doc = " The number of bytes occupied by the structure."] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = ""] # [doc = " Set to XHPTDC8_DEVICE_CONFIG_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " Create a trigger periodically."] # [doc = ""] # [doc = " There are two parameters: M = auto_trigger_period"] # [doc = " and N = auto_trigger_random_exponent that result in a distance between triggers of T clock cycles."] # [doc = " T = 1 + M + [1...2^N] clock cycles."] # [doc = " 0 <= M < 2^32"] # [doc = " 0 <= N < 32"] # [doc = " There is no enable or reset. The auto trigger is running continously."] # [doc = " The usage of this trigger can be configured in the channels."] pub auto_trigger_period : :: std :: os :: raw :: c_int , # [doc = " Create a trigger randomly."] # [doc = ""] # [doc = " There are two parameters: M = auto_trigger_period"] # [doc = " and N = auto_trigger_random_exponent that result in a distance between triggers of T clock cycles."] # [doc = " T = 1 + M + [1...2^N] clock cycles."] # [doc = " 0 <= M < 2^32"] # [doc = " 0 <= N < 32"] # [doc = " There is no enable or reset. The auto trigger is running continously."] # [doc = " The usage of this trigger can be configured in the channels."] pub auto_trigger_random_exponent : :: std :: os :: raw :: c_int , # [doc = " Set the threshold voltage for the input channels A . . .H."] # [doc = " threshold[0 - 7] : threshold for channels A...H."] # [doc = " Supported range is -1.32 V to +1.18 V. This should be close to 50% of the height of the input pulse."] # [doc = " The inputs are AC coupled."] # [doc = " Examples for various signaling standards are defined as XHPTDC8_THRESHOLD_*."] pub trigger_threshold : [f64 ; 8usize] , # [doc = " Configuration of the polarity of the external trigger sources."] pub trigger : [xhptdc8_trigger ; 16usize] , # [doc = " Configuration of the gating blocks."] pub gating_block : [xhptdc8_tiger_block ; 8usize] , # [doc = " Configuration of the TiGeR timing generator blocks."] pub tiger_block : [xhptdc8_tiger_block ; 9usize] , # [doc = " Configuration of the TDC channels."] pub channel : [xhptdc8_channel ; 8usize] , # [doc = " Configuration of ADC channel."] pub adc_channel : xhptdc8_adc_channel , # [doc = " Configure TDC alignemet"] # [doc = " If set to 'true', the phase of the two TDC chips is not realigned when capturing is restartet."] # [doc = " If set to 'false', it will be realigned on start_capture() (default)."] # [doc = " Should usually be left unchanged."] # [doc = " Value is either 'true' or 'false'."] pub skip_alignment : crono_bool_t , # [doc = " Define a signal source that is used for TDC alignment. Should usually be left unchanged."] # [doc = " If set to XHPTDC8_ALIGN_TIGER use TiGeR pulse for alignment (pulses are present on LEMO inputs during alignment)."] # [doc = " If set to XHPTDC8_ALIGN_PIN use internal alignment pins for alignment (no pulses are present on LEMO inputs during alignment)."] # [doc = " If set to XHPTDC8_ALIGN_RESERVED use internal alignment pins for alignment and do not disable after alignment (internal use only)."] pub alignment_source : :: std :: os :: raw :: c_int , } # [test] fn bindgen_test_layout_xhptdc8_device_configuration () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_device_configuration > () , 496usize , concat ! ("Size of: " , stringify ! (xhptdc8_device_configuration))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_device_configuration > () , 8usize , concat ! ("Alignment of " , stringify ! (xhptdc8_device_configuration))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . auto_trigger_period as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (auto_trigger_period))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . auto_trigger_random_exponent as * const _ as usize } , 12usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (auto_trigger_random_exponent))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . trigger_threshold as * const _ as usize } , 16usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (trigger_threshold))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . trigger as * const _ as usize } , 80usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (trigger))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . gating_block as * const _ as usize } , 112usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (gating_block))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . tiger_block as * const _ as usize } , 272usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (tiger_block))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . channel as * const _ as usize } , 452usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . adc_channel as * const _ as usize } , 472usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (adc_channel))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . skip_alignment as * const _ as usize } , 488usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (skip_alignment))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_device_configuration > ())) . alignment_source as * const _ as usize } , 492usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_device_configuration) , "::" , stringify ! (alignment_source))) ; } # [doc = " Contains global configuration information."] # [repr (C)] # [derive (Debug , Copy , Clone)] pub struct xhptdc8_manager_configuration { # [doc = " The number of bytes occupied by the structure."] pub size : :: std :: os :: raw :: c_int , # [doc = " A version number that is increased when the definition of the structure is changed."] # [doc = ""] # [doc = " Set to XHPTDC8_MANAGER_CONFIG_VERSION."] pub version : :: std :: os :: raw :: c_int , # [doc = " A structure with the configuration for an individual xHPTDC8-PCIe board."] # [doc = " Use the function xhptdc8_count_devices() to query how many entries contain valid information."] pub device_configs : [xhptdc8_device_configuration ; 6usize] , # [doc = " Structure with the parameters for grouping."] pub grouping : xhptdc8_grouping_configuration , # [doc = " Reserved for future use. Do not change!"] pub bin_to_ps : :: std :: option :: Option < unsafe extern "C" fn (arg1 : i64) -> i64 > , } # [test] fn bindgen_test_layout_xhptdc8_manager_configuration () { assert_eq ! (:: std :: mem :: size_of :: < xhptdc8_manager_configuration > () , 3112usize , concat ! ("Size of: " , stringify ! (xhptdc8_manager_configuration))) ; assert_eq ! (:: std :: mem :: align_of :: < xhptdc8_manager_configuration > () , 8usize , concat ! ("Alignment of " , stringify ! (xhptdc8_manager_configuration))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_configuration > ())) . size as * const _ as usize } , 0usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_configuration) , "::" , stringify ! (size))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_configuration > ())) . version as * const _ as usize } , 4usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_configuration) , "::" , stringify ! (version))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_configuration > ())) . device_configs as * const _ as usize } , 8usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_configuration) , "::" , stringify ! (device_configs))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_configuration > ())) . grouping as * const _ as usize } , 2984usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_configuration) , "::" , stringify ! (grouping))) ; assert_eq ! (unsafe { & (* (:: std :: ptr :: null :: < xhptdc8_manager_configuration > ())) . bin_to_ps as * const _ as usize } , 3104usize , concat ! ("Offset of field: " , stringify ! (xhptdc8_manager_configuration) , "::" , stringify ! (bin_to_ps))) ; } extern "C" { # [doc = " Gets default manager configuration. Copies the default configuration to the specified config pointer."] # [doc = ""] # [doc = " @param mgr_config[out]."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_default_configuration (mgr_config : * mut xhptdc8_manager_configuration) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Gets current configuration. Copies the current configuration to the specified config pointer."] # [doc = ""] # [doc = " @param mgr_config[out]."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_current_configuration (mgr_config : * mut xhptdc8_manager_configuration) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Configures the xHPTDC8 manager. The config information is copied, so can be changed afterwards."] # [doc = ""] # [doc = " @param mgr_config[out]."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_configure (mgr_config : * mut xhptdc8_manager_configuration) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Returns the number of boards present in the system that are supported by this driver."] # [doc = ""] # [doc = " @param error_code[out]. In case of success, it is assigned the value {0}, otherwise,"] # [doc = " it is assigned the relevant error code."] # [doc = " @param error_message[out]. In case of error, it is assigned the error message."] # [doc = ""] # [doc = " @returns The number of boards present in the system that are supported by this driver."] pub fn xhptdc8_count_devices (error_code : * mut :: std :: os :: raw :: c_int , error_message : * mut * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = "\tSets up the standard parameters."] # [doc = ""] # [doc = " Gets a set of default parameters for xhptdc8_init(). This must always be used to initialize"] # [doc = " the xtdc8manager_init_parameters structure."] # [doc = ""] # [doc = " @param init[in]."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_get_default_init_parameters (init : * mut xhptdc8_manager_init_parameters) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Opens and initializes all xHPTDC8-PCIe boards."] # [doc = ""] # [doc = " @param init[in]. A structure of type xhptdc8_manager_init_parameters that must be completely initialized."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_init (params : * mut xhptdc8_manager_init_parameters) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Returns the driver version, same format as xhptdc8_static_info.driver_revision. This function does"] # [doc = " not require a xHPTDC8-PCIe board to be present."] pub fn xhptdc8_get_driver_revision () -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Returns the driver version including SVN build revision as a string. This function does"] # [doc = " not require a xHPTDC8-PCIe board to be present."] pub fn xhptdc8_get_driver_revision_str () -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [doc = " Returns the state, corresponding to state code 'state', in string format."] # [doc = ""] # [doc = " @papram state[in]"] pub fn xhptdc8_device_state_to_str (state : :: std :: os :: raw :: c_int) -> * const :: std :: os :: raw :: c_char ; } extern "C" { # [doc = " Read from area of device flash reserved for user data."] # [doc = " Caller must provide buffer of given size."] # [doc = " Reserved area is of size XHPTDC8_USER_FLASH_SIZE"] # [doc = ""] # [doc = " @param index[in]. The index of the device."] # [doc = " @param flash_data[out]. Buffer provided by the caller of given size."] # [doc = " @param size[in]. Size of the buffer."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_read_user_flash (index : :: std :: os :: raw :: c_int , flash_data : * mut u8 , size : u32) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Write to area of device flash reserved for user data"] # [doc = " Caller must provide buffer of given size"] # [doc = " Reserved area is of size XHPTDC8_USER_FLASH_SIZE"] # [doc = ""] # [doc = " @param index[in]. The index of the device."] # [doc = " @param flash_data[out]. Buffer provided by the caller of given size."] # [doc = " @param size[in]. Size of the buffer."] # [doc = ""] # [doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."] pub fn xhptdc8_write_user_flash (index : :: std :: os :: raw :: c_int , flash_data : * mut u8 , size : u32) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " <summary>"] # [doc = " This functions applies all values provided in <paramref name=\"yaml_string\"/>"] # [doc = " on (overwrite) the corresponding memebers of <paramref name=\"manager_config\"/>."] # [doc = " Members that are not referenced in yaml_string will be left unchanged in configs."] # [doc = " </summary>"] # [doc = " <param name=\"manager_config\">Initialized xhptdc8_manager_configuration object</param>"] # [doc = " <param name=\"yaml_string\">YAML string that has the values to be applied</param>"] # [doc = " <returns>"] # [doc = " <para>+ve Numebr: count of device configuraions updated at success. <br/></para>"] # [doc = " <para>-ve Number: error code, XHPTDC8_INVALID_ARGUMENTS or one of the"] # [doc = " \"XHPTDC8_APPLY_YAML_\" prefixed error codes defined in \"xhptdc8_util.h\".</para>"] # [doc = " </returns>"] pub fn xhptdc8_apply_yaml (cfg : * mut xhptdc8_manager_configuration , yaml_string : * const :: std :: os :: raw :: c_char) -> :: std :: os :: raw :: c_int ; } extern "C" { # [doc = " Returns the error messages from all boards."] # [doc = ""] # [doc = " @param include_ok[in]: Outputs a line even if the board or the manager has no error"] # [doc = " @param fixed_length[in]: Outputs a line for 8 boards, even if there are less boards in the system"] # [doc = ""] # [doc = " @returns null-terminated error message for all boards."] # [doc = " The pointer should not be deallocated using `delete` or similar deallocation functions."] pub fn xhptdc8_get_all_error_messages (include_ok : crono_bool_t , fixed_length : crono_bool_t) -> * const :: std :: os :: raw :: c_char ; }