/* automatically generated by rust-bindgen 0.58.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const CRONO_OK: u32 = 0;
pub const CRONO_WINDRIVER_NOT_FOUND: u32 = 1;
pub const CRONO_DEVICE_NOT_FOUND: u32 = 2;
pub const CRONO_NOT_INITIALIZED: u32 = 3;
pub const CRONO_WRONG_STATE: u32 = 4;
pub const CRONO_INVALID_DEVICE: u32 = 5;
pub const CRONO_BUFFER_ALLOC_FAILED: u32 = 6;
pub const CRONO_TDC_NO_EDGE_FOUND: u32 = 7;
pub const CRONO_INVALID_BUFFER_PARAMETERS: u32 = 8;
pub const CRONO_INVALID_CONFIG_PARAMETERS: u32 = 9;
pub const CRONO_WINDOW_CALIBRATION_FAILED: u32 = 10;
pub const CRONO_HARDWARE_FAILURE: u32 = 11;
pub const CRONO_INVALID_ADC_MODE: u32 = 12;
pub const CRONO_SYNCHRONIZATION_FAILED: u32 = 13;
pub const CRONO_DEVICE_OPEN_FAILED: u32 = 14;
pub const CRONO_INTERNAL_ERROR: u32 = 15;
pub const CRONO_CALIBRATION_FAILURE: u32 = 16;
pub const CRONO_INVALID_ARGUMENTS: u32 = 17;
pub const CRONO_INSUFFICIENT_DATA: u32 = 18;
pub const CRONO_PACKET_TYPE_8_BIT_SIGNED: u32 = 0;
pub const CRONO_PACKET_TYPE_16_BIT_SIGNED: u32 = 1;
pub const CRONO_PACKET_TYPE_32_BIT_SIGNED: u32 = 2;
pub const CRONO_PACKET_TYPE_64_BIT_SIGNED: u32 = 3;
pub const CRONO_PACKET_TYPE_8_BIT_UNSIGNED: u32 = 4;
pub const CRONO_PACKET_TYPE_16_BIT_UNSIGNED: u32 = 5;
pub const CRONO_PACKET_TYPE_32_BIT_UNSIGNED: u32 = 6;
pub const CRONO_PACKET_TYPE_64_BIT_UNSIGNED: u32 = 7;
pub const CRONO_PACKET_TYPE_TDC_DATA: u32 = 8;
pub const CRONO_PACKET_TYPE_TIMESTAMP_ONLY: u32 = 128;
pub const CRONO_PACKET_TYPE_END_OF_BUFFER: u32 = 129;
pub const CRONO_PACKET_TYPE_TRIGGER_PATTERN: u32 = 130;
pub const CRONO_PACKET_FLAG_SHORTENED: u32 = 1;
pub const CRONO_PACKET_FLAG_PACKETS_LOST: u32 = 2;
pub const CRONO_PACKET_FLAG_OVERFLOW: u32 = 4;
pub const CRONO_PACKET_FLAG_TRIGGER_MISSED: u32 = 8;
pub const CRONO_PACKET_FLAG_DMA_FIFO_FULL: u32 = 16;
pub const CRONO_PACKET_FLAG_HOST_BUFFER_FULL: u32 = 32;
pub const CRONO_PACKET_FLAG_TDC_NO_EDGE: u32 = 64;
pub const CRONO_DEVICE_UNKNOWN: u32 = 0;
pub const CRONO_DEVICE_HPTDC: u32 = 1;
pub const CRONO_DEVICE_NDIGO5G: u32 = 2;
pub const CRONO_DEVICE_NDIGO250M: u32 = 4;
pub const CRONO_DEVICE_NDIGO_AVRG: u32 = 3;
pub const CRONO_DEVICE_XTDC4: u32 = 6;
pub const CRONO_DEVICE_FMC_TDC10: u32 = 7;
pub const CRONO_DEVICE_TIMETAGGER4: u32 = 8;
pub const CRONO_DEVICE_D_AVE12: u32 = 9;
pub const CRONO_DEVICE_D_AVE14: u32 = 10;
pub const CRONO_DEVICE_NDIGO2G14: u32 = 11;
pub const CRONO_DEVICE_XHPTDC8: u32 = 12;
pub const CRONO_DEVICE_NDIGO6G12: u32 = 13;
pub const CRONO_DEVICE_STATE_CREATED: u32 = 0;
pub const CRONO_DEVICE_STATE_INITIALIZED: u32 = 1;
pub const CRONO_DEVICE_STATE_CONFIGURED: u32 = 2;
pub const CRONO_DEVICE_STATE_CAPTURING: u32 = 3;
pub const CRONO_DEVICE_STATE_PAUSED: u32 = 4;
pub const CRONO_DEVICE_STATE_CLOSED: u32 = 5;
pub const CRONO_READ_OK: u32 = 0;
pub const CRONO_READ_NO_DATA: u32 = 1;
pub const CRONO_READ_INTERNAL_ERROR: u32 = 2;
pub const CRONO_READ_TIMEOUT: u32 = 3;
pub const CRONO_PCIE_RX_ERROR: u32 = 1;
pub const CRONO_PCIE_BAD_TLP: u32 = 64;
pub const CRONO_PCIE_BAD_DLLP: u32 = 128;
pub const CRONO_PCIE_REPLAY_NUM_ROLLOVER: u32 = 256;
pub const CRONO_PCIE_REPLAY_TIMER_TIMEOUT: u32 = 4096;
pub const CRONO_PCIE_ADVISORY_NON_FATAL: u32 = 8192;
pub const CRONO_PCIE_CORRECTED_INTERNAL_ERROR: u32 = 16384;
pub const CRONO_PCIE_HEADER_LOG_OVERFLOW: u32 = 32768;
pub const CRONO_PCIE_UNC_UNDEFINED: u32 = 1;
pub const CRONO_PCIE_UNC_DATA_LINK_PROTOCOL_ERROR: u32 = 16;
pub const CRONO_PCIE_UNC_SURPRISE_DOWN_ERROR: u32 = 32;
pub const CRONO_PCIE_UNC_POISONED_TLP: u32 = 4096;
pub const CRONO_PCIE_UNC_FLOW_CONTROL_PROTOCOL_ERROR: u32 = 8192;
pub const CRONO_PCIE_UNC_COMPLETION_TIMEOUT: u32 = 16384;
pub const CRONO_PCIE_UNC_COMPLETER_ABORT: u32 = 32768;
pub const CRONO_PCIE_UNC_UNEXPECTED_COMPLETION: u32 = 65536;
pub const CRONO_PCIE_UNC_RECEIVER_OVERFLOW_ERROR: u32 = 131072;
pub const CRONO_PCIE_UNC_MALFORMED_TLP: u32 = 262144;
pub const CRONO_PCIE_UNC_ECRC_ERROR: u32 = 524288;
pub const CRONO_PCIE_UNC_UNSUPPORED_REQUEST_ERROR: u32 = 1048576;
pub const CRONO_PCIE_CORRECTABLE_FLAG: u32 = 1;
pub const CRONO_PCIE_UNCORRECTABLE_FLAG: u32 = 2;
pub const XHPTDC8_API_VERSION: u32 = 1;
pub const XHPTDC8_STATIC_INFO_VERSION: u32 = 1;
pub const XHPTDC8_FAST_INFO_VERSION: u32 = 2;
pub const XHPTDC8_PARAM_INFO_VERSION: u32 = 2;
pub const XHPTDC8_TEMP_INFO_VERSION: u32 = 3;
pub const XHPTDC8_CLOCK_INFO_VERSION: u32 = 1;
pub const XHPTDC8_DEVICE_CONFIG_VERSION: u32 = 3;
pub const XHPTDC8_MANAGER_CONFIG_VERSION: u32 = 1;
pub const XHPTDC8_MANAGER_DEVICES_MAX: u32 = 6;
pub const XHPTDC8_TDC_CHANNEL_COUNT: u32 = 8;
pub const XHPTDC8_GATE_COUNT: u32 = 8;
pub const XHPTDC8_TIGER_COUNT: u32 = 9;
pub const XHPTDC8_TRIGGER_COUNT: u32 = 16;
pub const XHPTDC8_BUFFER_ALLOCATE: u32 = 0;
pub const XHPTDC8_BUFFER_USE_PHYSICAL: u32 = 1;
pub const XHPTDC8_INPUT_BASELINE: f64 = 1.32;
pub const XHPTDC8_THRESHOLD_P_NIM: f64 = 0.35;
pub const XHPTDC8_THRESHOLD_P_CMOS: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_LVCMOS_33: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_LVCMOS_25: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_LVCMOS_18: f64 = 0.9;
pub const XHPTDC8_THRESHOLD_P_TTL: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_LVTTL_33: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_LVTTL_25: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_SSTL_3: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_P_SSTL_2: f64 = 1.18;
pub const XHPTDC8_THRESHOLD_N_NIM: f64 = -0.35;
pub const XHPTDC8_THRESHOLD_N_CMOS: f64 = -1.32;
pub const XHPTDC8_THRESHOLD_N_LVCMOS_33: f64 = -1.32;
pub const XHPTDC8_THRESHOLD_N_LVCMOS_25: f64 = -1.25;
pub const XHPTDC8_THRESHOLD_N_LVCMOS_18: f64 = -0.9;
pub const XHPTDC8_THRESHOLD_N_TTL: f64 = -1.32;
pub const XHPTDC8_THRESHOLD_N_LVTTL_33: f64 = -1.32;
pub const XHPTDC8_THRESHOLD_N_LVTTL_25: f64 = -1.25;
pub const XHPTDC8_THRESHOLD_N_SSTL_3: f64 = -1.32;
pub const XHPTDC8_THRESHOLD_N_SSTL_2: f64 = -1.25;
pub const XHPTDC8_TRIGGER_SOURCE_NONE: u32 = 0;
pub const XHPTDC8_TRIGGER_SOURCE_A: u32 = 1;
pub const XHPTDC8_TRIGGER_SOURCE_B: u32 = 2;
pub const XHPTDC8_TRIGGER_SOURCE_C: u32 = 4;
pub const XHPTDC8_TRIGGER_SOURCE_D: u32 = 8;
pub const XHPTDC8_TRIGGER_SOURCE_E: u32 = 16;
pub const XHPTDC8_TRIGGER_SOURCE_F: u32 = 32;
pub const XHPTDC8_TRIGGER_SOURCE_G: u32 = 64;
pub const XHPTDC8_TRIGGER_SOURCE_H: u32 = 128;
pub const XHPTDC8_TRIGGER_SOURCE_TDC1_SYNC: u32 = 256;
pub const XHPTDC8_TRIGGER_SOURCE_TDC2_SYNC: u32 = 512;
pub const XHPTDC8_TRIGGER_SOURCE_TDC_EXT_SYNC: u32 = 1024;
pub const XHPTDC8_TRIGGER_SOURCE_ADC1_CNV: u32 = 2048;
pub const XHPTDC8_TRIGGER_SOURCE_ADC2_CNV: u32 = 4096;
pub const XHPTDC8_TRIGGER_SOURCE_SOFTWARE: u32 = 8192;
pub const XHPTDC8_TRIGGER_SOURCE_AUTO: u32 = 16384;
pub const XHPTDC8_TRIGGER_SOURCE_ONE: u32 = 32768;
pub const XHPTDC8_TDCHIT_TYPE_RISING: u32 = 1;
pub const XHPTDC8_TDCHIT_TYPE_ERROR: u32 = 2;
pub const XHPTDC8_TDCHIT_TYPE_ERROR_TIMESTAMP_LOST: u32 = 4;
pub const XHPTDC8_TDCHIT_TYPE_ERROR_ROLLOVER_LOST: u32 = 8;
pub const XHPTDC8_TDCHIT_TYPE_ERROR_PACKETS_LOST: u32 = 16;
pub const XHPTDC8_TDCHIT_TYPE_ERROR_SHORTENED: u32 = 32;
pub const XHPTDC8_TDCHIT_TYPE_ERROR_DMA_FIFO_FULL: u32 = 64;
pub const XHPTDC8_TDCHIT_TYPE_ERROR_HOST_BUFFER_FULL: u32 = 128;
pub const XHPTDC8_TDCHIT_TYPE_ADC_INTERNAL: u32 = 1;
pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR: u32 = 2;
pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR_UNUSED: u32 = 4;
pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR_INVALID_TRIGGER: u32 = 8;
pub const XHPTDC8_TDCHIT_TYPE_ADC_ERROR_DATA_LOST: u32 = 16;
pub const XHPTDC8_OK: u32 = 0;
pub const XHPTDC8_DEVICE_NOT_FOUND: u32 = 2;
pub const XHPTDC8_WRONG_STATE: u32 = 4;
pub const XHPTDC8_INVALID_DEVICE: u32 = 5;
pub const XHPTDC8_BUFFER_ALLOC_FAILED: u32 = 6;
pub const XHPTDC8_TDC_NO_EDGE_FOUND: u32 = 7;
pub const XHPTDC8_INVALID_BUFFER_PARAMETERS: u32 = 8;
pub const XHPTDC8_INVALID_CONFIG_PARAMETERS: u32 = 9;
pub const XHPTDC8_TDC_ALIGNMENT_FAILED: u32 = 10;
pub const XHPTDC8_HARDWARE_FAILURE: u32 = 11;
pub const XHPTDC8_INVALID_ADC_MODE: u32 = 12;
pub const XHPTDC8_SYNCHRONIZATION_FAILED: u32 = 13;
pub const XHPTDC8_DEVICE_OPEN_FAILED: u32 = 14;
pub const XHPTDC8_INTERNAL_ERROR: u32 = 15;
pub const XHPTDC8_CALIBRATION_FAILURE: u32 = 16;
pub const XHPTDC8_INVALID_ARGUMENTS: u32 = 17;
pub const XHPTDC8_INSUFFICIENT_DATA: u32 = 18;
pub const XHPTDC8_DEVICE_STATE_CREATED: u32 = 0;
pub const XHPTDC8_DEVICE_STATE_INITIALIZED: u32 = 1;
pub const XHPTDC8_DEVICE_STATE_CONFIGURED: u32 = 2;
pub const XHPTDC8_DEVICE_STATE_CAPTURING: u32 = 3;
pub const XHPTDC8_DEVICE_STATE_PAUSED: u32 = 4;
pub const XHPTDC8_DEVICE_STATE_CLOSED: u32 = 5;
pub const XHPTDC8_USER_FLASH_SIZE: u32 = 65536;
pub const XHPTDC8_NOF_CHANNELS_PER_CARD: u32 = 10;
pub const XHPTDC8_CALIBARTION_DATE_LEN: u32 = 20;
pub const XHPTDC8_GATE_OFF: u32 = 0;
pub const XHPTDC8_GATE_ON: u32 = 1;
pub const XHPTDC8_TIGER_OFF: u32 = 0;
pub const XHPTDC8_TIGER_OUTPUT: u32 = 1;
pub const XHPTDC8_TIGER_BIDI: u32 = 2;
pub const XHPTDC8_TIGER_BIPOLAR: u32 = 3;
pub const XHPTDC8_TIGER_MAX_BIPOLAR_PULSE_LENGTH: u32 = 15;
pub const XHPTDC8_GROUPING_VETO_OFF: u32 = 0;
pub const XHPTDC8_GROUPING_VETO_INSIDE: u32 = 1;
pub const XHPTDC8_GROUPING_VETO_OUTSIDE: u32 = 2;
pub const XHPTDC8_ALIGN_TIGER: u32 = 0;
pub const XHPTDC8_ALIGN_PIN: u32 = 1;
pub const XHPTDC8_ALIGN_RESERVED: u32 = 2;
pub const XHPTDC8_APPLY_YAML_INVALID_ARGUMENT: i32 = -1;
pub const XHPTDC8_APPLY_YAML_ERR_NO_CONF_MNGR: i32 = -10;
pub const XHPTDC8_APPLY_YAML_ERR_EMPTY_CONF_MNGR: i32 = -11;
pub const XHPTDC8_APPLY_YAML_ERR_CONFS_EXCEED_MAX: i32 = -22;
pub const XHPTDC8_APPLY_YAML_INVALID_CONFS_STRUTC: i32 = -23;
pub const XHPTDC8_APPLY_YAML_ERR_EMPTY_DEV_CONF: i32 = -31;
pub const XHPTDC8_APPLY_YAML_INVALID_AUTO_TRIG_PRD: i32 = -32;
pub const XHPTDC8_APPLY_YAML_INVALID_AUTO_TRIG_RAND: i32 = -33;
pub const XHPTDC8_APPLY_YAML_INVALID_SKIP_ALGNMT: i32 = -34;
pub const XHPTDC8_APPLY_YAML_INVALID_ALGNMT_SRCE: i32 = -35;
pub const XHPTDC8_APPLY_YAML_INVALID_ALGNMT_OFFSTAT: i32 = -36;
pub const XHPTDC8_APPLY_YAML_THRESHOLDS_EXCEED_MAX: i32 = -40;
pub const XHPTDC8_APPLY_YAML_INVALID_THRESHOLD: i32 = -41;
pub const XHPTDC8_APPLY_YAML_INVALID_THRESHOLD_STRUCT: i32 = -42;
pub const XHPTDC8_APPLY_YAML_INVALID_TRIGGER_FALL: i32 = -51;
pub const XHPTDC8_APPLY_YAML_INVALID_TRIGGER_RISING: i32 = -52;
pub const XHPTDC8_APPLY_YAML_INVALID_TRIGGER_STRUCT: i32 = -53;
pub const XHPTDC8_APPLY_YAML_ERR_TRIGGER_EXCEED_MAX: i32 = -54;
pub const XHPTDC8_APPLY_YAML_ERR_GTBLCK_EXCEED_MAX: i32 = -60;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_MODE: i32 = -61;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_NEGATE: i32 = -62;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_RETRIG: i32 = -63;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_START: i32 = -64;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_STOP: i32 = -65;
pub const XHPTDC8_APPLY_YAML_GTBLCK_STOP_B4_START: i32 = -66;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_SOURCES: i32 = -67;
pub const XHPTDC8_APPLY_YAML_GTBLCK_INVALID_STRUCT: i32 = -68;
pub const XHPTDC8_APPLY_YAML_ERR_CHANNELS_EXCEED_MAX: i32 = -70;
pub const XHPTDC8_APPLY_YAML_INVALID_CHANNEL_ENABLE: i32 = -71;
pub const XHPTDC8_APPLY_YAML_INVALID_CHANNEL_RISING: i32 = -72;
pub const XHPTDC8_APPLY_YAML_INVALID_CHANNEL_STRUCT: i32 = -73;
pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_ENABLE: i32 = -80;
pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_WDRO: i32 = -81;
pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_WDI: i32 = -82;
pub const XHPTDC8_APPLY_YAML_INVALID_ADC_CHANNEL_TRTHRESH: i32 = -83;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_ENABLED: i32 = -90;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_TRIGCH: i32 = -91;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_ZEROCH: i32 = -92;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_ZEROCHOFF: i32 = -93;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_TRIGDT: i32 = -95;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETOMD: i32 = -97;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETORZERO: i32 = -98;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_RANGE_START: i32 = -99;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_RANGE_STOP: i32 = -100;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_WINDO_START: i32 = -101;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_WINDO_STOP: i32 = -102;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETO_START: i32 = -103;
pub const XHPTDC8_APPLY_YAML_INVALID_GROUPING_VETO_STOP: i32 = -104;
pub const XHPTDC8_APPLY_YAML_ERR_TGRBLCKS_EXCEED_MAX: i32 = -120;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_MODE: i32 = -121;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_NEGATE: i32 = -122;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_RETRIG: i32 = -123;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_START: i32 = -124;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_STOP: i32 = -125;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_STOP_B4_START: i32 = -126;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_SOURCES: i32 = -127;
pub const XHPTDC8_APPLY_YAML_TGRBLCK_INVALID_STRUCT: i32 = -128;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type size_t = ::std::os::raw::c_ulonglong;
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type crono_bool_t = u8;
#[doc = " Basic device data structure for synchronizing cronologic Ndigo5G and HPTDC8 devices"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_device {
    pub device_type: ::std::os::raw::c_int,
    #[doc = " For HPTDC use this board id, Ndigo uses configured board id"]
    pub board_id: ::std::os::raw::c_int,
    pub device: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_crono_device() {
    assert_eq!(
        ::std::mem::size_of::<crono_device>(),
        16usize,
        concat!("Size of: ", stringify!(crono_device))
    );
    assert_eq!(
        ::std::mem::align_of::<crono_device>(),
        8usize,
        concat!("Alignment of ", stringify!(crono_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_device>())).device_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_device),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_device>())).board_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_device),
            "::",
            stringify!(board_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_device>())).device as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_device),
            "::",
            stringify!(device)
        )
    );
}
#[doc = " Packet data structure in ring buffer for packets carrying varying amounts of data."]
#[doc = ""]
#[doc = " The size of the data[] array is given in the length field."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_packet {
    pub channel: u8,
    pub card: u8,
    pub type_: u8,
    pub flags: u8,
    pub length: u32,
    pub timestamp: i64,
    pub data: [u64; 1usize],
}
#[test]
fn bindgen_test_layout_crono_packet() {
    assert_eq!(
        ::std::mem::size_of::<crono_packet>(),
        24usize,
        concat!("Size of: ", stringify!(crono_packet))
    );
    assert_eq!(
        ::std::mem::align_of::<crono_packet>(),
        8usize,
        concat!("Alignment of ", stringify!(crono_packet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).channel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).card as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(card)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).type_ as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).flags as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).length as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).timestamp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_packet>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Packet data structure in ring buffer for packets carrying only the header."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_packet_only_timestamp {
    pub channel: u8,
    pub card: u8,
    pub type_: u8,
    pub flags: u8,
    pub length: u32,
    pub timestamp: i64,
}
#[test]
fn bindgen_test_layout_crono_packet_only_timestamp() {
    assert_eq!(
        ::std::mem::size_of::<crono_packet_only_timestamp>(),
        16usize,
        concat!("Size of: ", stringify!(crono_packet_only_timestamp))
    );
    assert_eq!(
        ::std::mem::align_of::<crono_packet_only_timestamp>(),
        8usize,
        concat!("Alignment of ", stringify!(crono_packet_only_timestamp))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_packet_only_timestamp>())).channel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet_only_timestamp),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_packet_only_timestamp>())).card as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet_only_timestamp),
            "::",
            stringify!(card)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_packet_only_timestamp>())).type_ as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet_only_timestamp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_packet_only_timestamp>())).flags as *const _ as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet_only_timestamp),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_packet_only_timestamp>())).length as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet_only_timestamp),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_packet_only_timestamp>())).timestamp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_packet_only_timestamp),
            "::",
            stringify!(timestamp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct crono_pcie_info {
    #[doc = " \\brief organizes power supply of PCIe lanes"]
    pub pwr_mgmt: u32,
    #[doc = " \\brief Number of PCIe lanes that the card uses."]
    #[doc = ""]
    #[doc = " Should be 4 for Ndigo5G"]
    pub link_width: u32,
    #[doc = " \\brief Maximum size in bytes for one PCIe transaction"]
    #[doc = ""]
    #[doc = " depends on system configuration."]
    pub max_payload: u32,
    #[doc = " \\brief Data rate of the PCIe card."]
    #[doc = ""]
    #[doc = " depends on system configuration."]
    pub link_speed: u32,
    #[doc = " \\brief != 0 if the PCIe error status is supported for this"]
    #[doc = " device"]
    pub error_status_supported: u32,
    #[doc = " \\brief Correctable error status flags, directly from PCIe config"]
    #[doc = " register"]
    #[doc = ""]
    #[doc = " Useful for debugging PCIe problems"]
    pub correctable_error_status: u32,
    #[doc = " \\brief Uncorrectable error status flags, directly from PCIe"]
    #[doc = " config register"]
    #[doc = ""]
    #[doc = " Useful for debugging PCIe problems"]
    pub uncorrectable_error_status: u32,
    #[doc = " \\brief for future extension"]
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_crono_pcie_info() {
    assert_eq!(
        ::std::mem::size_of::<crono_pcie_info>(),
        32usize,
        concat!("Size of: ", stringify!(crono_pcie_info))
    );
    assert_eq!(
        ::std::mem::align_of::<crono_pcie_info>(),
        4usize,
        concat!("Alignment of ", stringify!(crono_pcie_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_pcie_info>())).pwr_mgmt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(pwr_mgmt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_pcie_info>())).link_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(link_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_pcie_info>())).max_payload as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(max_payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_pcie_info>())).link_speed as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(link_speed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_pcie_info>())).error_status_supported as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(error_status_supported)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_pcie_info>())).correctable_error_status as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(correctable_error_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<crono_pcie_info>())).uncorrectable_error_status as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(uncorrectable_error_status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<crono_pcie_info>())).reserved as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(crono_pcie_info),
            "::",
            stringify!(reserved)
        )
    );
}
#[doc = " struct for the initialization of the xHPTDC8Manager."]
#[doc = " This structure MUST be completely INITIALIZED although"]
#[doc = " xhptdc8_get_default_init_parameters() will set sensible defaults."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_manager_init_parameters {
    #[doc = " Version number of the xhptdc8_manager_init_parameters structure"]
    #[doc = " Is set to XHPTDC8_API_VERSION by"]
    #[doc = " xhptdc8_get_default_init_parameters(). Must be left unchanged."]
    pub version: ::std::os::raw::c_int,
    #[doc = " The minimum size of the DMA buffer."]
    #[doc = " If set to 0, the default size of 16MB is used."]
    pub buffer_size: i64,
    #[doc = " A variant, for reconfiguring the chip for future extension."]
    pub variant: ::std::os::raw::c_int,
    #[doc = " A constant for the different devices of cronologic CRONO_DEVICE_*."]
    #[doc = " Initialized by xhptdc8_get_default_init_parameters()."]
    #[doc = " Must be left unchanged."]
    pub device_type: ::std::os::raw::c_int,
    #[doc = " The update delay of the writing pointer after a packet has been send"]
    #[doc = " over PCIe. Specified in multiples of 16 ns. Should not be changed by"]
    #[doc = " the user. The base unit is 16 to 32 ns."]
    pub dma_read_delay: ::std::os::raw::c_int,
    #[doc = " Several xHPTDC8-PCIe can be used in sync."]
    #[doc = " If set to 1 enable multiboard operation. If set to 0 disable"]
    #[doc = " multiboard operation. Value is either 'true' or 'false'."]
    pub multiboard: crono_bool_t,
    #[doc = " Select external 10 MHz reference."]
    #[doc = " If set to 1 use external 10 MHz reference. If set to 0 use internal"]
    #[doc = " reference. Value is either 'true' or 'false'."]
    pub use_ext_clock: crono_bool_t,
    #[doc = " Ignore calibration values read from device flash."]
    #[doc = " Value is either 'true' or 'false'."]
    pub ignore_calibration: crono_bool_t,
}
#[test]
fn bindgen_test_layout_xhptdc8_manager_init_parameters() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_manager_init_parameters>(),
        32usize,
        concat!("Size of: ", stringify!(xhptdc8_manager_init_parameters))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_manager_init_parameters>(),
        8usize,
        concat!("Alignment of ", stringify!(xhptdc8_manager_init_parameters))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).buffer_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(buffer_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).variant as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(variant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).device_type as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).dma_read_delay as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(dma_read_delay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).multiboard as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(multiboard)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).use_ext_clock as *const _
                as usize
        },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(use_ext_clock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_init_parameters>())).ignore_calibration
                as *const _ as usize
        },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_init_parameters),
            "::",
            stringify!(ignore_calibration)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TDCHit {
    #[doc = " The time stamp of the hit in picoseconds."]
    #[doc = " If grouping is enabled the timestamp is relative to the trigger or"]
    #[doc = " the separate zero reference of the group. Otherwise the timestampe is"]
    #[doc = " continuously counting up from the call to start_capture()"]
    pub time: i64,
    #[doc = " For the first board in the system this 0 to 7 for the TDC channels A"]
    #[doc = " to H. 8 or 9 for ADC data. Data from channels 8 and 9 should usually"]
    #[doc = " be treated as data from the same channel. For the other boards the"]
    #[doc = " channel number is incremented by board_id * 10"]
    pub channel: u8,
    #[doc = " Additional information on the type of hit recorded."]
    #[doc = " It is of one of the values XHPTDC8_TDCHIT_TYPE_* or'ed with error"]
    #[doc = " flags if required."]
    pub type_: u8,
    #[doc = " For ADC hits this contains the sampled voltage. For TDC hits the"]
    #[doc = " content is undefined."]
    pub bin: u16,
    #[doc = " Data reserved for internal usage."]
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_TDCHit() {
    assert_eq!(
        ::std::mem::size_of::<TDCHit>(),
        16usize,
        concat!("Size of: ", stringify!(TDCHit))
    );
    assert_eq!(
        ::std::mem::align_of::<TDCHit>(),
        8usize,
        concat!("Alignment of ", stringify!(TDCHit))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDCHit>())).time as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TDCHit),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDCHit>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TDCHit),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDCHit>())).type_ as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TDCHit),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDCHit>())).bin as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(TDCHit),
            "::",
            stringify!(bin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TDCHit>())).reserved as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TDCHit),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[doc = " Read a multitude of hits into a buffer provided by the user."]
    #[doc = " If grouping is enabled a single group is read."]
    #[doc = " If grouping is disabled all availabe data is read."]
    #[doc = " In all cases, data is copied to buffer up to the size of the buffer."]
    #[doc = ""]
    #[doc = " @param hit_buf[out]. Buffer allocated and provdied by the user."]
    #[doc = " @param read_max[out]. Size of the buffer."]
    #[doc = ""]
    #[doc = " @returns Returns the number of read hits."]
    pub fn xhptdc8_read_hits(hit_buf: *mut TDCHit, read_max: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " TODO"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param absolute_trigger_timestamp[out]. The absolute trigger timestamp in"]
    #[doc = "picoseconds."]
    #[doc = " @param hit_counter[out].\t\t\tBuffer allocated and provded by"]
    #[doc = "the user. This array provides the hit counts per channel. The maximum count is"]
    #[doc = "defined by number_of_hits. Set the buffer size to number_of_channels. Channels"]
    #[doc = "8 and 9 mod XHPTDC8_NOF_CHANNELS_PER_CARD stay empty."]
    #[doc = " @param tdc_array[out].\t\t\tBuffer allocated and provded by"]
    #[doc = "the user. This is a matrix containing a list timestamps per channel. Set the"]
    #[doc = "buffer size to number_of_channels x number_of_hits. Remark: Adc channels per"]
    #[doc = "card are merged to channel 8 mod XHPTDC8_NOF_CHANNELS_PER_CARD, so 9 mod"]
    #[doc = "XHPTDC8_NOF_CHANNELS_PER_CARD stays empty."]
    #[doc = " @param adc_counter[out].\t\t\tBuffer allocated and provded by"]
    #[doc = "the user. This array provides the hit counts per adc channel. The maximum"]
    #[doc = "count is defined by number_of_hits. Set the buffer size to devices count (use"]
    #[doc = "function xhptdc8_count_devices)."]
    #[doc = " @param adc_value[out].\t\t\tBuffer allocated and provded by"]
    #[doc = "the user. This array provides the adc value per channel. The maximum is"]
    #[doc = "defined by number_of_hits. Set the buffer size to devices count."]
    #[doc = " @param number_of_tdcs[in].\t\tThis is the devices count that can be"]
    #[doc = "calculated by the function xhptdc8_count_devices."]
    #[doc = " @param number_of_channels[in].\tThis has to be calculated by"]
    #[doc = "XHPTDC8_NOF_CHANNELS_PER_CARD * number_of_tdcs."]
    #[doc = " @param number_of_hits[in].\t\tThis is used to define buffer sizes."]
    #[doc = ""]
    #[doc = " @returns Returns the number of read hits."]
    pub fn xhptdc8_read_group_matrix(
        absolute_trigger_timestamp: *mut i64,
        hit_counter: *mut i32,
        tdc_array: *mut i64,
        adc_counter: *mut i32,
        adc_value: *mut i32,
        number_of_tdcs: i32,
        number_of_channels: i32,
        number_of_hits: i32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Finalize the driver for this device."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_close() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start the timing generator of an individual board."]
    #[doc = " This can be done independently of the state of the data acquisition"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_start_tiger(index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop the timing generator of an individual board."]
    #[doc = " This can be done independently of the state of the data acquisition"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_stop_tiger(index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Start data acquisition."]
    #[doc = " Device manager must be initialized using xhptdc8_init()."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_start_capture() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pause a started data acquisition."]
    #[doc = " It doesn�t allow for a configuration change."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_pause_capture() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this to resume data acquisition after a call to xhptdc8_pause_capture()."]
    #[doc = " It doesn�t allow for a configuration change."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_continue_capture() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Stop data acquisition."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_stop_capture() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Generate a software trigger event."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_software_trigger(index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " Structure contains static information."]
#[doc = ""]
#[doc = " This structure contains information about the board that does not change"]
#[doc = " during run time. It is provided by the function xhptdc8_get_static_info()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_static_info {
    #[doc = " The number of bytes occupied by the structure."]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed. Set to XHPTDC8_STATIC_INFO_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " ID of the board."]
    #[doc = " All xHPTDC8-PCIe boards in the system are numbered according in order"]
    #[doc = " of their serial numbers starting at zero."]
    pub board_id: ::std::os::raw::c_int,
    #[doc = " Encoded version number for the driver."]
    #[doc = ""]
    #[doc = " The lower three bytes contain a triple level hierarchy of version"]
    #[doc = " numbers. E.g. 0x010103 codes version 1.1.3."]
    #[doc = ""]
    #[doc = " A change in the first digit generally requires a recompilation of"]
    #[doc = " user applications. Change in the second digit denote significant"]
    #[doc = " improvements or changes that don't break compatibility and the third"]
    #[doc = " digit changes with minor bugfixes and the like."]
    pub driver_revision: ::std::os::raw::c_int,
    #[doc = " The build number of the driver according to cronologic�s internal"]
    #[doc = " versioning system."]
    pub driver_build_revision: ::std::os::raw::c_int,
    #[doc = " Revision number of the FPGA configuration"]
    pub firmware_revision: ::std::os::raw::c_int,
    #[doc = " Board revision number."]
    #[doc = ""]
    #[doc = " The board revision number can be read from a register. It is a four"]
    #[doc = " bit number that changes when the schematic of the board is changed."]
    #[doc = " - 0: Experimental first board Version. Labeled \"Rev. 1\""]
    #[doc = " - 2: First commercial Version. Labeled \"Rev. 2\""]
    pub board_revision: ::std::os::raw::c_int,
    #[doc = " Describes the schematic configuration of the board."]
    #[doc = ""]
    #[doc = " The same board schematic can be populated in multiple variants."]
    #[doc = " This is a eight bit-code that can be read from a register."]
    pub board_configuration: ::std::os::raw::c_int,
    #[doc = " Subversion revision id of the FPGA configuration."]
    #[doc = ""]
    #[doc = " A number to track builds of the firmware in more detail than the"]
    #[doc = " firmware revision. It changes with every change in the firmware, even"]
    #[doc = " if there is no visible effect for the user. The subversion revision"]
    #[doc = " number can be read from a register."]
    pub subversion_revision: ::std::os::raw::c_int,
    #[doc = " 16bit factory ID of the TDC chip."]
    #[doc = ""]
    #[doc = " This is the chipID as read from the 16 bit TDC chip id register."]
    pub chip_id: [::std::os::raw::c_int; 2usize],
    #[doc = " Serial number"]
    #[doc = ""]
    #[doc = " With year and running number in 8.24 format. The number is identical"]
    #[doc = " to the one printed on the silvery sticker on the board."]
    pub board_serial: ::std::os::raw::c_int,
    #[doc = " High 32 bits of 64 bit manufacturer serial number of the flash chip."]
    pub flash_serial_high: u32,
    #[doc = " Low 32 bits of 64 bit manufacturer serial number of the flash chip."]
    pub flash_serial_low: u32,
    #[doc = " Calibration data read from flash is valid."]
    #[doc = ""]
    #[doc = " If not 'false', the driver found valid calibration data in the flash"]
    #[doc = " on the board and is using it."]
    pub flash_valid: crono_bool_t,
    #[doc = " Calibration date"]
    #[doc = ""]
    #[doc = " DIN EN ISO 8601 string YYYY-MM-DD HH:DD describing the time when the"]
    #[doc = " card was calibrated."]
    pub calibration_date: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_xhptdc8_static_info() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_static_info>(),
        80usize,
        concat!("Size of: ", stringify!(xhptdc8_static_info))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_static_info>(),
        4usize,
        concat!("Alignment of ", stringify!(xhptdc8_static_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_static_info>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_static_info>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_static_info>())).board_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(board_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).driver_revision as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(driver_revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).driver_build_revision as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(driver_build_revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).firmware_revision as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(firmware_revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).board_revision as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(board_revision)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).board_configuration as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(board_configuration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).subversion_revision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(subversion_revision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_static_info>())).chip_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(chip_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).board_serial as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(board_serial)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).flash_serial_high as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(flash_serial_high)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).flash_serial_low as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(flash_serial_low)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_static_info>())).flash_valid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(flash_valid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_static_info>())).calibration_date as *const _ as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_static_info),
            "::",
            stringify!(calibration_date)
        )
    );
}
extern "C" {
    #[doc = " Returns static information about the device."]
    #[doc = ""]
    #[doc = " Gets a structure that contains information about the board that does not"]
    #[doc = " change during run time."]
    #[doc = ""]
    #[doc = " @param index[in].The index of the device."]
    #[doc = " @param info[out]. Buffer allocated and provided by the user to have a copy of"]
    #[doc = " the structure."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_static_info(
        index: ::std::os::raw::c_int,
        info: *mut xhptdc8_static_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Contains fast dynamic information."]
#[doc = ""]
#[doc = " This structure is filled using function xhptdc8_get_fast_info()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_fast_info {
    #[doc = " The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed."]
    #[doc = ""]
    #[doc = " Set to XHPTDC8_FAST_INFO_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Speed of the FPGA fan in rounds per minute."]
    #[doc = ""]
    #[doc = " Reports 0, if no fan is present."]
    pub fpga_rpm: ::std::os::raw::c_int,
    #[doc = " Alert bits from temperature sensor and the system monitor."]
    #[doc = ""]
    #[doc = " Bit 0 is set if the TDC temperature exceeds 140 �C. In this case the"]
    #[doc = " TDC did shut down and the device needs to be reinitialized."]
    pub alerts: ::std::os::raw::c_int,
    #[doc = " Reports power management confguration of PCIe lanes."]
    #[doc = " Should always be 0."]
    pub pcie_pwr_mgmt: ::std::os::raw::c_int,
    #[doc = " Number of PCIe lanes the card uses."]
    #[doc = " Should always be 1 for the xHPTDC8-PCIe."]
    pub pcie_link_width: ::std::os::raw::c_int,
    #[doc = " Maximum size for a single PCIe transaction in bytes. Depends on"]
    #[doc = " system configuration."]
    pub pcie_max_payload: ::std::os::raw::c_int,
    #[doc = " The current state of the device."]
    #[doc = " Should be one of the values XHPTDC8_DEVICE_STATE_*"]
    pub state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xhptdc8_fast_info() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_fast_info>(),
        32usize,
        concat!("Size of: ", stringify!(xhptdc8_fast_info))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_fast_info>(),
        4usize,
        concat!("Alignment of ", stringify!(xhptdc8_fast_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_fast_info>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_fast_info>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_fast_info>())).fpga_rpm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(fpga_rpm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_fast_info>())).alerts as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(alerts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_fast_info>())).pcie_pwr_mgmt as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(pcie_pwr_mgmt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_fast_info>())).pcie_link_width as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(pcie_link_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_fast_info>())).pcie_max_payload as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(pcie_max_payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_fast_info>())).state as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_fast_info),
            "::",
            stringify!(state)
        )
    );
}
extern "C" {
    #[doc = " Returns fast dynamic information about the device."]
    #[doc = ""]
    #[doc = " This call gets a structure that contains dynamic information that can be"]
    #[doc = " obtained within a few microseconds."]
    #[doc = ""]
    #[doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of"]
    #[doc = " the structure."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_fast_info(
        index: ::std::os::raw::c_int,
        info: *mut xhptdc8_fast_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Contains information that may change with configuration"]
#[doc = ""]
#[doc = " Structure is filled by xhptdc8_get_param_info()."]
#[doc = " This structure contains information that changes indirectly due to"]
#[doc = " configuration changes."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_param_info {
    #[doc = " The number of bytes occupied by the structure."]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed."]
    #[doc = ""]
    #[doc = " Set to XHPTDC8_PARAM_INFO_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Binsize (in ps) of the measured TDC data."]
    #[doc = ""]
    #[doc = " The TDC main clk is running at a frequency of 76.8 GHz resulting in a"]
    #[doc = " binsize of ~13.0208 ps."]
    pub binsize: f64,
    #[doc = " Number of TDC channels of the board."]
    #[doc = ""]
    #[doc = " It's currently fixed at 8."]
    pub channels: ::std::os::raw::c_int,
    #[doc = " Bit assignment of each enabled input channel."]
    #[doc = ""]
    #[doc = " Bit 0 <= n < 8 is set if channel n is enabled."]
    pub channel_mask: ::std::os::raw::c_int,
    #[doc = " The total amount of DMA buffer in bytes."]
    pub total_buffer: i64,
}
#[test]
fn bindgen_test_layout_xhptdc8_param_info() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_param_info>(),
        32usize,
        concat!("Size of: ", stringify!(xhptdc8_param_info))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_param_info>(),
        8usize,
        concat!("Alignment of ", stringify!(xhptdc8_param_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_param_info>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_param_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_param_info>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_param_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_param_info>())).binsize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_param_info),
            "::",
            stringify!(binsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_param_info>())).channels as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_param_info),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_param_info>())).channel_mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_param_info),
            "::",
            stringify!(channel_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_param_info>())).total_buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_param_info),
            "::",
            stringify!(total_buffer)
        )
    );
}
extern "C" {
    #[doc = " Returns information that may change with configuration"]
    #[doc = ""]
    #[doc = " Gets a structure that contains information that changes indirectly due to"]
    #[doc = " configuration changes."]
    #[doc = ""]
    #[doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of"]
    #[doc = " the structure."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_param_info(
        index: ::std::os::raw::c_int,
        info: *mut xhptdc8_param_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Contains temperature measurements"]
#[doc = ""]
#[doc = " CAVE: TDC temp diode takes about 2.5 us after wakeup from power down to"]
#[doc = " provide a valid measurement Structure filled by"]
#[doc = " xhptdc8_get_temperature_info()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_temperature_info {
    #[doc = " The number of bytes occupied by the structure"]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed."]
    #[doc = ""]
    #[doc = " Set to XHPTDC8_TEMP_INFO_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Temperature for each of the TDC chips in �C."]
    pub tdc: [f32; 2usize],
}
#[test]
fn bindgen_test_layout_xhptdc8_temperature_info() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_temperature_info>(),
        16usize,
        concat!("Size of: ", stringify!(xhptdc8_temperature_info))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_temperature_info>(),
        4usize,
        concat!("Alignment of ", stringify!(xhptdc8_temperature_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_temperature_info>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_temperature_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_temperature_info>())).version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_temperature_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_temperature_info>())).tdc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_temperature_info),
            "::",
            stringify!(tdc)
        )
    );
}
extern "C" {
    #[doc = " Get temperature measurements from multiple sources on the board."]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    #[doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of"]
    #[doc = " the structure."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_temperature_info(
        index: ::std::os::raw::c_int,
        info: *mut xhptdc8_temperature_info,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Contains information about the active clock source."]
#[doc = ""]
#[doc = " Structure is filled by xhptdc8_clock_info()."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_clock_info {
    #[doc = " The number of bytes occupied by the structure."]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed."]
    #[doc = ""]
    #[doc = " Set to XHPTDC8_CLOCK_INFO_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " CDCE62005 PLL locked. Set if the jitter cleaning PLL clock"]
    #[doc = " synthesizer achieved lock. Value is either 'true' or 'false'."]
    pub cdce_locked: crono_bool_t,
    #[doc = " Version information from the CDCE62005 clock synthesizer."]
    pub cdce_version: ::std::os::raw::c_int,
    #[doc = " Source for the clock synthesizer is usually the 10MHz on board"]
    #[doc = " oscillator. Value: 'false': internal 10 MHz, 'true': LEMO clock"]
    pub use_ext_clock: crono_bool_t,
    #[doc = " Set if the FPGA datapath PLLs achieved lock."]
    #[doc = " Value is either 'true' or 'false'."]
    pub fpga_locked: crono_bool_t,
}
#[test]
fn bindgen_test_layout_xhptdc8_clock_info() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_clock_info>(),
        20usize,
        concat!("Size of: ", stringify!(xhptdc8_clock_info))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_clock_info>(),
        4usize,
        concat!("Alignment of ", stringify!(xhptdc8_clock_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_clock_info>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_clock_info),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_clock_info>())).version as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_clock_info),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_clock_info>())).cdce_locked as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_clock_info),
            "::",
            stringify!(cdce_locked)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_clock_info>())).cdce_version as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_clock_info),
            "::",
            stringify!(cdce_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_clock_info>())).use_ext_clock as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_clock_info),
            "::",
            stringify!(use_ext_clock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_clock_info>())).fpga_locked as *const _ as usize },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_clock_info),
            "::",
            stringify!(fpga_locked)
        )
    );
}
extern "C" {
    #[doc = " Get information on clocking configuration an status."]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    #[doc = " @param info[out]. Buffer allocated and provdied by the user to have a copy of"]
    #[doc = " the structure."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_clock_info(
        index: ::std::os::raw::c_int,
        info: *mut xhptdc8_clock_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns most recent error message."]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device. If set to -1 returns error message"]
    #[doc = " of the manager."]
    pub fn xhptdc8_get_last_error_message(
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the type of the device as CRONO_DEVICE_XHPTDC8."]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    pub fn xhptdc8_get_device_type(index: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
#[doc = " Contains TDC channel settings."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_channel {
    #[doc = " Enable TDC channel."]
    #[doc = " Value is either 'true' or 'false'."]
    pub enable: crono_bool_t,
    #[doc = " Select which edge of the signal is measured by the TDC."]
    #[doc = " Value is either 'true' or 'false'."]
    pub rising: crono_bool_t,
}
#[test]
fn bindgen_test_layout_xhptdc8_channel() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_channel>(),
        2usize,
        concat!("Size of: ", stringify!(xhptdc8_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_channel>(),
        1usize,
        concat!("Alignment of ", stringify!(xhptdc8_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_channel>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_channel),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_channel>())).rising as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_channel),
            "::",
            stringify!(rising)
        )
    );
}
#[doc = " Contains settings of timing generator."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_tiger_block {
    #[doc = " Enables the desired mode of operation for the TiGeR."]
    #[doc = " It is of one of the values XHPTDC8_TIGER_*"]
    pub mode: ::std::os::raw::c_int,
    #[doc = " Inverts output polarity."]
    #[doc = " For gating blocks, a value of 'false' enables inputs between start"]
    #[doc = " and stop, A value of 'true' enables outputs outside that interval."]
    #[doc = " The TiGeR creates a high pulse from start to stop unless negated."]
    #[doc = " Default value is 'false'."]
    pub negate: crono_bool_t,
    #[doc = " Enables retrigger setting."]
    #[doc = " If enabled, the timer is reset to the value of the start parameter,"]
    #[doc = " whenever the input signal is set while waiting to reach the stop"]
    #[doc = " time. Value is either 'true' or 'false'. Default value is 'false'"]
    pub retrigger: crono_bool_t,
    #[doc = " Not implemented."]
    pub extend: crono_bool_t,
    #[doc = " The start time at which the TiGeR or Gate output is set, relative to"]
    #[doc = " the trigger input. It is in multiples of 20 ns/3 = 6.6 ns. Must"]
    #[doc = " fullfil condition: 0 <= start <= stop <= (2^16 - 1)"]
    pub start: ::std::os::raw::c_int,
    #[doc = " The duration from start time in which the TiGeR or Gate output is"]
    #[doc = " set, relative to the trigger input. It is in multiples of 20 ns/3"]
    #[doc = " = 6.6 ns. Must fullfil condition: 0 <= start <= stop <= (2^16 - 1)"]
    pub stop: ::std::os::raw::c_int,
    #[doc = " A bit mask with a bit set for all trigger sources that can trigger"]
    #[doc = " this TiGeR or Gate block. Default value is XHPTDC8_TRIGGER_SOURCE_A."]
    pub sources: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xhptdc8_tiger_block() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_tiger_block>(),
        20usize,
        concat!("Size of: ", stringify!(xhptdc8_tiger_block))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_tiger_block>(),
        4usize,
        concat!("Alignment of ", stringify!(xhptdc8_tiger_block))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).negate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(negate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).retrigger as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(retrigger)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).extend as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(extend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).stop as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_tiger_block>())).sources as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_tiger_block),
            "::",
            stringify!(sources)
        )
    );
}
#[doc = " For each input, this structure determines wheter rising or falling edges on"]
#[doc = " the inputs create trigger events for the TiGeR and gating blocks."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_trigger {
    #[doc = " If set to 'true', a trigger event is created inside the FPGA at the"]
    #[doc = " falling edge. Value is either 'true' or 'false'."]
    pub falling: crono_bool_t,
    #[doc = " If set to 'true', a trigger event is created inside the FPGA at the"]
    #[doc = " rising edge. Value is either 'true' or 'false'."]
    pub rising: crono_bool_t,
}
#[test]
fn bindgen_test_layout_xhptdc8_trigger() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_trigger>(),
        2usize,
        concat!("Size of: ", stringify!(xhptdc8_trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_trigger>(),
        1usize,
        concat!("Alignment of ", stringify!(xhptdc8_trigger))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_trigger>())).falling as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_trigger),
            "::",
            stringify!(falling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_trigger>())).rising as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_trigger),
            "::",
            stringify!(rising)
        )
    );
}
#[doc = " ADC channel config"]
#[doc = " Contains ADC channel settings"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_adc_channel {
    #[doc = " Enable ADC measurements."]
    #[doc = " Value is either 'true' or 'false'."]
    pub enable: crono_bool_t,
    #[doc = " Send watchdog measurements."]
    #[doc = " Value is either 'true' or 'false'."]
    pub watchdog_readout: crono_bool_t,
    #[doc = " Number of 150 MHz clock cycles between watchdog triggers."]
    pub watchdog_interval: ::std::os::raw::c_int,
    #[doc = " Trigger threshold of ADC trigger input."]
    #[doc = " Always triggers at the falling edge of the TRG input when set threshold"]
    #[doc = " is crossed."]
    pub trigger_threshold: f64,
}
#[test]
fn bindgen_test_layout_xhptdc8_adc_channel() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_adc_channel>(),
        16usize,
        concat!("Size of: ", stringify!(xhptdc8_adc_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_adc_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(xhptdc8_adc_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<xhptdc8_adc_channel>())).enable as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_adc_channel),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_adc_channel>())).watchdog_readout as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_adc_channel),
            "::",
            stringify!(watchdog_readout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_adc_channel>())).watchdog_interval as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_adc_channel),
            "::",
            stringify!(watchdog_interval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_adc_channel>())).trigger_threshold as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_adc_channel),
            "::",
            stringify!(trigger_threshold)
        )
    );
}
#[doc = " This structure configures the behaviour of the grouping functionality."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_grouping_configuration {
    pub enabled: crono_bool_t,
    #[doc = " Channel number that is used to trigger the creation of a group."]
    #[doc = ""]
    #[doc = " By default the trigger channels defines the zero point reference for"]
    #[doc = " the group event timestamps."]
    pub trigger_channel: ::std::os::raw::c_int,
    #[doc = " Use this to define additional trigger channels."]
    #[doc = " There is an OR-disjuction with the trigger_channel."]
    pub trigger_channel_bitmask: u64,
    #[doc = " Start of group range relative to the trigger channel."]
    #[doc = " Values in the interval from range_start to range_stop are included in"]
    #[doc = " the group. Either or both values can be negative to create"]
    #[doc = " common-stop behaviour. -2^63 <= range_start < range_stop < 2^63"]
    #[doc = " Intervals are always provided in picoseconds, independently of the"]
    #[doc = " bin size of the TDC."]
    pub range_start: i64,
    #[doc = " End of group range relative to the trigger channel."]
    #[doc = " Intervals are always provided in picoseconds, independently of the"]
    #[doc = " bin size of the TDC."]
    pub range_stop: i64,
    #[doc = " Dead time before new group start trigger is recognized."]
    #[doc = " 0 <= trigger_deadtime < 2^63"]
    #[doc = " Intervals are always provided in picoseconds, independently of the"]
    #[doc = " bin size of the TDC."]
    pub trigger_deadtime: i64,
    #[doc = " Optionally, a different channel can be used to calculate the relative"]
    #[doc = " timestamps in a group. This is disabled per default by setting this"]
    #[doc = " parameter to -1."]
    pub zero_channel: ::std::os::raw::c_int,
    #[doc = " This offset in picoseconds is added to relative timestamps within a"]
    #[doc = " group."]
    pub zero_channel_offset: i64,
    #[doc = " Set a bitmask of channels, a group is only created"]
    #[doc = " if there is at least one"]
    #[doc = " hit in the windows defined by windows_start and window_stop."]
    #[doc = " Usage is equivalent to trigger_channel_bitmask."]
    pub window_hit_channels: u64,
    #[doc = " A group is only created if there is at least one hit in the window"]
    #[doc = " defined by window_start and window_stop, and when require_window_hit"]
    #[doc = " is set 'true'. -2^63 <= window_start < window_stop < 2^63 Intervals"]
    #[doc = " are always provided in picoseconds, independently of the bin size of"]
    #[doc = " the TDC."]
    pub window_start: i64,
    #[doc = " A group is only created if there is at least one hit in the window"]
    #[doc = " defined by window_start and window_stop, and when require_window_hit"]
    #[doc = " is set 'true'. -2^63 <= window_start < window_stop < 2^63 Intervals"]
    #[doc = " are always provided in picoseconds, independently of the bin size of"]
    #[doc = " the TDC."]
    pub window_stop: i64,
    #[doc = " A window defined by veto_start and veto_stop can be used to suppress"]
    #[doc = " hits. The functionality is very similar to the gating blocks but is"]
    #[doc = " defined in software. This feature can not be used to improve FIFO"]
    #[doc = " usage or PCIe bandwidth usage. It is of one of the values"]
    #[doc = " XHPTDC8_GROUPING_VETO_*"]
    pub veto_mode: ::std::os::raw::c_int,
    #[doc = " A window defined by veto_start and veto_stop can be used to suppress"]
    #[doc = " hits. -2^63 <= veto_start <= veto_stop < 2^63"]
    pub veto_start: i64,
    #[doc = " A window defined by veto_start and veto_stop can be used to suppress"]
    #[doc = " hits. -2^63 <= veto_start <= veto_stop < 2^63"]
    pub veto_stop: i64,
    #[doc = "\tIf veto is enabled, veto filtering is active for channels"]
    #[doc = "\tdefined by a channel bitmask."]
    #[doc = "\tAs default, filtering is active for all channels."]
    pub veto_active_channels: u64,
    pub veto_relative_to_zero: crono_bool_t,
    pub ignore_empty_events: crono_bool_t,
    pub overlap: crono_bool_t,
}
#[test]
fn bindgen_test_layout_xhptdc8_grouping_configuration() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_grouping_configuration>(),
        120usize,
        concat!("Size of: ", stringify!(xhptdc8_grouping_configuration))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_grouping_configuration>(),
        8usize,
        concat!("Alignment of ", stringify!(xhptdc8_grouping_configuration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).enabled as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).trigger_channel as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(trigger_channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).trigger_channel_bitmask
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(trigger_channel_bitmask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).range_start as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(range_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).range_stop as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(range_stop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).trigger_deadtime as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(trigger_deadtime)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).zero_channel as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(zero_channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).zero_channel_offset
                as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(zero_channel_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).window_hit_channels
                as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(window_hit_channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).window_start as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(window_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).window_stop as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(window_stop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).veto_mode as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(veto_mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).veto_start as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(veto_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).veto_stop as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(veto_stop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).veto_active_channels
                as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(veto_active_channels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).veto_relative_to_zero
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(veto_relative_to_zero)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).ignore_empty_events
                as *const _ as usize
        },
        113usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(ignore_empty_events)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_grouping_configuration>())).overlap as *const _ as usize
        },
        114usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_grouping_configuration),
            "::",
            stringify!(overlap)
        )
    );
}
#[doc = " This is the structure containing the configuration information."]
#[doc = " It uses the multiple substructures to configure various aspects of the board."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_device_configuration {
    #[doc = " The number of bytes occupied by the structure."]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed."]
    #[doc = ""]
    #[doc = " Set to XHPTDC8_DEVICE_CONFIG_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " Create a trigger periodically."]
    #[doc = ""]
    #[doc = " There are two parameters: M = auto_trigger_period"]
    #[doc = " and N = auto_trigger_random_exponent that result in a distance"]
    #[doc = " between triggers of T clock cycles. T = 1 + M + [1...2^N] clock"]
    #[doc = " cycles. 0 <= M < 2^32 0 <= N < 32 There is no enable or reset. The"]
    #[doc = " auto trigger is running continously. The usage of this trigger can be"]
    #[doc = " configured in the channels."]
    pub auto_trigger_period: ::std::os::raw::c_int,
    #[doc = " Create a trigger randomly."]
    #[doc = ""]
    #[doc = " There are two parameters: M = auto_trigger_period"]
    #[doc = " and N = auto_trigger_random_exponent that result in a distance"]
    #[doc = " between triggers of T clock cycles. T = 1 + M + [1...2^N] clock"]
    #[doc = " cycles. 0 <= M < 2^32 0 <= N < 32 There is no enable or reset. The"]
    #[doc = " auto trigger is running continously. The usage of this trigger can be"]
    #[doc = " configured in the channels."]
    pub auto_trigger_random_exponent: ::std::os::raw::c_int,
    #[doc = " Set the threshold voltage for the input channels A . . .H."]
    #[doc = " threshold[0 - 7] : threshold for channels A...H."]
    #[doc = " Supported range is -1.32 V to +1.18 V. This should be close to 50% of"]
    #[doc = " the height of the input pulse. The inputs are AC coupled. Examples"]
    #[doc = " for various signaling standards are defined as XHPTDC8_THRESHOLD_*."]
    pub trigger_threshold: [f64; 8usize],
    #[doc = " Configuration of the polarity of the external trigger sources."]
    pub trigger: [xhptdc8_trigger; 16usize],
    #[doc = " Configuration of the gating blocks."]
    pub gating_block: [xhptdc8_tiger_block; 8usize],
    #[doc = " Configuration of the TiGeR timing generator blocks."]
    pub tiger_block: [xhptdc8_tiger_block; 9usize],
    #[doc = " Configuration of the TDC channels."]
    pub channel: [xhptdc8_channel; 8usize],
    #[doc = " Configuration of ADC channel."]
    pub adc_channel: xhptdc8_adc_channel,
    #[doc = " Configure TDC alignemet"]
    #[doc = " If set to 'true', the phase of the two TDC chips is not realigned"]
    #[doc = " when capturing is restartet. If set to 'false', it will be realigned"]
    #[doc = " on xhptdc8_configure() (default). Should usually be left unchanged. Value"]
    #[doc = " is either 'true' or 'false'."]
    pub skip_alignment: crono_bool_t,
    #[doc = " Define a signal source that is used for TDC alignment. Should usually"]
    #[doc = " be left unchanged. If set to XHPTDC8_ALIGN_TIGER use TiGeR pulse for"]
    #[doc = " alignment (pulses are present on LEMO inputs during alignment). If"]
    #[doc = " set to XHPTDC8_ALIGN_PIN use internal alignment pins for alignment"]
    #[doc = " (no pulses are present on LEMO inputs during alignment). If set to"]
    #[doc = " XHPTDC8_ALIGN_RESERVED use internal alignment pins for alignment and"]
    #[doc = " do not disable after alignment (internal use only)."]
    pub alignment_source: ::std::os::raw::c_int,
    #[doc = " Select TDC alignment pin state when not in use."]
    #[doc = " If set to 0 set to GND."]
    #[doc = " If set to 1 set to VCCIO."]
    #[doc = " If set to 2 set to high-Z."]
    pub alignment_off_state: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_xhptdc8_device_configuration() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_device_configuration>(),
        504usize,
        concat!("Size of: ", stringify!(xhptdc8_device_configuration))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_device_configuration>(),
        8usize,
        concat!("Alignment of ", stringify!(xhptdc8_device_configuration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).auto_trigger_period as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(auto_trigger_period)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).auto_trigger_random_exponent
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(auto_trigger_random_exponent)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).trigger_threshold as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(trigger_threshold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).trigger as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(trigger)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).gating_block as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(gating_block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).tiger_block as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(tiger_block)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).channel as *const _ as usize
        },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).adc_channel as *const _
                as usize
        },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(adc_channel)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).skip_alignment as *const _
                as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(skip_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).alignment_source as *const _
                as usize
        },
        492usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(alignment_source)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_device_configuration>())).alignment_off_state as *const _
                as usize
        },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_device_configuration),
            "::",
            stringify!(alignment_off_state)
        )
    );
}
#[doc = " Contains global configuration information."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct xhptdc8_manager_configuration {
    #[doc = " The number of bytes occupied by the structure."]
    pub size: ::std::os::raw::c_int,
    #[doc = " A version number that is increased when the definition of the"]
    #[doc = " structure is changed."]
    #[doc = ""]
    #[doc = " Set to XHPTDC8_MANAGER_CONFIG_VERSION."]
    pub version: ::std::os::raw::c_int,
    #[doc = " A structure with the configuration for an individual xHPTDC8-PCIe"]
    #[doc = " board. Use the function xhptdc8_count_devices() to query how many"]
    #[doc = " entries contain valid information."]
    pub device_configs: [xhptdc8_device_configuration; 6usize],
    #[doc = " Structure with the parameters for grouping."]
    pub grouping: xhptdc8_grouping_configuration,
    #[doc = " Reserved for future use. Do not change!"]
    pub bin_to_ps: ::std::option::Option<unsafe extern "C" fn(arg1: i64) -> i64>,
}
#[test]
fn bindgen_test_layout_xhptdc8_manager_configuration() {
    assert_eq!(
        ::std::mem::size_of::<xhptdc8_manager_configuration>(),
        3160usize,
        concat!("Size of: ", stringify!(xhptdc8_manager_configuration))
    );
    assert_eq!(
        ::std::mem::align_of::<xhptdc8_manager_configuration>(),
        8usize,
        concat!("Alignment of ", stringify!(xhptdc8_manager_configuration))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_configuration>())).size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_configuration),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_configuration>())).version as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_configuration),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_configuration>())).device_configs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_configuration),
            "::",
            stringify!(device_configs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_configuration>())).grouping as *const _ as usize
        },
        3032usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_configuration),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<xhptdc8_manager_configuration>())).bin_to_ps as *const _ as usize
        },
        3152usize,
        concat!(
            "Offset of field: ",
            stringify!(xhptdc8_manager_configuration),
            "::",
            stringify!(bin_to_ps)
        )
    );
}
extern "C" {
    #[doc = " Gets default manager configuration. Copies the default configuration to the"]
    #[doc = " specified config pointer."]
    #[doc = ""]
    #[doc = " @param mgr_config[out]."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_default_configuration(
        mgr_config: *mut xhptdc8_manager_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets current configuration. Copies the current configuration to the specified"]
    #[doc = " config pointer."]
    #[doc = ""]
    #[doc = " @param mgr_config[out]."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_current_configuration(
        mgr_config: *mut xhptdc8_manager_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Configures the xHPTDC8 manager. The config information is copied, so can be"]
    #[doc = " changed afterwards."]
    #[doc = ""]
    #[doc = " @param mgr_config[out]."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_configure(
        mgr_config: *mut xhptdc8_manager_configuration,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the number of boards present in the system that are supported by this"]
    #[doc = " driver."]
    #[doc = ""]
    #[doc = " @param error_code[out]. In case of success, it is assigned the value {0},"]
    #[doc = " otherwise, it is assigned the relevant error code."]
    #[doc = " @param error_message[out]. In case of error, it is assigned the error"]
    #[doc = " message."]
    #[doc = ""]
    #[doc = " @returns The number of boards present in the system that are supported by"]
    #[doc = " this driver."]
    pub fn xhptdc8_count_devices(
        error_code: *mut ::std::os::raw::c_int,
        error_message: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\tSets up the standard parameters."]
    #[doc = ""]
    #[doc = " Gets a set of default parameters for xhptdc8_init(). This must always be used"]
    #[doc = " to initialize the xtdc8manager_init_parameters structure."]
    #[doc = ""]
    #[doc = " @param init[in]."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_get_default_init_parameters(
        init: *mut xhptdc8_manager_init_parameters,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Opens and initializes all xHPTDC8-PCIe boards."]
    #[doc = ""]
    #[doc = " @param init[in]. A structure of type xhptdc8_manager_init_parameters that"]
    #[doc = " must be completely initialized."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_init(params: *mut xhptdc8_manager_init_parameters) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the driver version, same format as"]
    #[doc = " xhptdc8_static_info.driver_revision. This function does not require a"]
    #[doc = " xHPTDC8-PCIe board to be present."]
    pub fn xhptdc8_get_driver_revision() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the driver version including SVN build revision as a string. This"]
    #[doc = " function does not require a xHPTDC8-PCIe board to be present."]
    pub fn xhptdc8_get_driver_revision_str() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the state, corresponding to state code 'state', in string format."]
    #[doc = ""]
    #[doc = " @papram state[in]"]
    pub fn xhptdc8_device_state_to_str(
        state: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Read from area of device flash reserved for user data."]
    #[doc = " Caller must provide buffer of given size."]
    #[doc = " Reserved area is of size XHPTDC8_USER_FLASH_SIZE"]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    #[doc = " @param flash_data[out]. Buffer provided by the caller of given size."]
    #[doc = " @param size[in]. Size of the buffer."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_read_user_flash(
        index: ::std::os::raw::c_int,
        flash_data: *mut u8,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Write to area of device flash reserved for user data"]
    #[doc = " Caller must provide buffer of given size"]
    #[doc = " Reserved area is of size XHPTDC8_USER_FLASH_SIZE"]
    #[doc = ""]
    #[doc = " @param index[in]. The index of the device."]
    #[doc = " @param flash_data[out]. Buffer provided by the caller of given size."]
    #[doc = " @param size[in]. Size of the buffer."]
    #[doc = ""]
    #[doc = " @returns XHPTDC8_OK in case of success, or error code in case of error."]
    pub fn xhptdc8_write_user_flash(
        index: ::std::os::raw::c_int,
        flash_data: *mut u8,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " \\defgroup pciefuncts Functions for PCIe information"]
    #[doc = "\t\\brief reads the PCIe info like correctable and uncorrectable"]
    #[doc = ""]
    pub fn xhptdc8_get_pcie_info(
        index: ::std::os::raw::c_int,
        pcie_info: *mut crono_pcie_info,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "\t\\brief clear pci errors, only useful for PCIE problem debuggin"]
    #[doc = "  flags"]
    #[doc = "  CRONO_PCIE_CORRECTABLE_FLAG clear all correctable errors"]
    #[doc = "  CRONO_PCIE_UNCORRECTABLE_FLAG clear all uncorrectable errors"]
    pub fn xhptdc8_clear_pcie_errors(
        index: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " <summary>"]
    #[doc = " This functions applies all values provided in <paramref name=\"yaml_string\"/>"]
    #[doc = " on (overwrite) the corresponding memebers of <paramref name=\"manager_config\"/>."]
    #[doc = " Members that are not referenced in yaml_string will be left unchanged in configs."]
    #[doc = " </summary>"]
    #[doc = " <param name=\"manager_config\">Initialized xhptdc8_manager_configuration object</param>"]
    #[doc = " <param name=\"yaml_string\">YAML string that has the values to be applied</param>"]
    #[doc = " <returns>"]
    #[doc = " <para>+ve Numebr: count of device configuraions updated at success. <br/></para>"]
    #[doc = " <para>-ve Number: error code, XHPTDC8_INVALID_ARGUMENTS or one of the"]
    #[doc = " \"XHPTDC8_APPLY_YAML_\" prefixed error codes defined in \"xhptdc8_util.h\".</para>"]
    #[doc = " </returns>"]
    pub fn xhptdc8_apply_yaml(
        cfg: *mut xhptdc8_manager_configuration,
        yaml_string: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Returns the error messages from all boards."]
    #[doc = ""]
    #[doc = " @param include_ok[in]: Outputs a line even if the board or the manager has no error"]
    #[doc = " @param fixed_length[in]: Outputs a line for 8 boards, even if there are less boards in the system"]
    #[doc = ""]
    #[doc = " @returns null-terminated error message for all boards."]
    #[doc = " The pointer should not be deallocated using `delete` or similar deallocation functions."]
    pub fn xhptdc8_get_all_error_messages(
        include_ok: crono_bool_t,
        fixed_length: crono_bool_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @returns null-terminated error message of YAML error code `err_code`."]
    #[doc = " The pointer should not be deallocated using `delete` or similar deallocation functions."]
    pub fn xhptdc8_get_err_message(
        err_code: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
